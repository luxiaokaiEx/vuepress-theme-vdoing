<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Spring源码分析 | 卢晓凯博客</title>
    <meta name="generator" content="VuePress 1.9.5">
    <link rel="icon" href="/vuepress-theme-vdoing/img/favicon.ico">
    <meta name="description" content="让梦想在指尖上飞舞，让精彩在低调中绽放">
    <meta name="keywords" content="前端博客,个人技术博客,前端,前端开发,前端框架,web前端,前端面试题,技术文档,学习,面试,JavaScript,js,ES6,TypeScript,vue,python,css3,html5,Node,git,github,markdown">
    <meta name="baidu-site-verification" content="7F55weZDDc">
    <meta name="theme-color" content="#11a8cd">
    
    <link rel="preload" href="/vuepress-theme-vdoing/assets/css/0.styles.d4b58c13.css" as="style"><link rel="preload" href="/vuepress-theme-vdoing/assets/js/app.524f9bbc.js" as="script"><link rel="preload" href="/vuepress-theme-vdoing/assets/js/3.421046c6.js" as="script"><link rel="preload" href="/vuepress-theme-vdoing/assets/js/57.40a59478.js" as="script"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/1.1c4b91eb.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/10.b5605df0.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/100.3617a9ce.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/101.671d2ef2.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/102.e2acc1e2.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/103.4ac7c35d.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/104.ff1a5cd4.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/105.b9b9bdd9.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/106.12ecd1c6.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/107.b1444980.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/108.d15a1858.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/109.152968cb.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/11.e1ce6106.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/110.ba878ba8.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/111.723424fe.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/112.13637258.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/113.2069d871.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/114.08967e7f.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/115.6f0c7cbb.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/116.0f8ce6df.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/117.80325fd6.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/118.37d549e5.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/119.e53984d6.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/12.9fa432ed.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/120.c892ebed.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/121.aaa46d72.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/122.7d50318d.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/123.6a237dba.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/124.43d4b03a.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/125.c886aa6d.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/126.f130081a.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/127.68016df1.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/128.78177bf5.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/129.40e73c9d.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/13.eab955cd.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/130.fc14defe.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/131.911defbe.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/132.b612896e.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/133.161f1085.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/134.a355e233.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/135.032ca8d9.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/136.799312c5.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/137.d61a0e9c.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/138.b4c1ceef.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/139.a8bdf33b.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/14.1dcfd146.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/140.00894512.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/141.1d10bc5f.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/142.4d8622bc.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/143.ce8fb9cc.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/144.33e5b07f.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/145.6a837f35.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/146.b7fa4db4.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/147.cd21aba6.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/148.b162f845.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/149.0cd1ab18.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/15.a3ef8eb2.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/150.3d009746.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/151.1b4e591c.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/152.bb4523ba.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/153.2d9f30c9.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/154.7df03411.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/155.d39b6864.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/156.f5244294.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/157.18605624.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/158.d009453b.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/159.69a91cdb.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/16.50cb3098.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/160.6a8f2617.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/161.098e8431.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/162.f049a359.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/163.ae5ceb64.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/164.2c8ae85b.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/165.0ec98e10.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/166.26972bf8.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/167.e2affb66.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/168.4b8f4b5d.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/169.12756ecf.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/17.e3f1fb18.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/170.7d86239d.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/171.0a3b04bf.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/172.13fa4817.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/173.534e3723.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/174.09ffb352.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/175.1f8afd41.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/176.0a045a1b.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/177.8f643a0b.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/178.233b5794.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/179.76761ac3.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/18.d4a07abd.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/180.0811451e.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/181.9ab71792.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/182.52041172.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/183.e0fb8d32.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/184.a54daefc.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/185.8f056be5.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/186.cb8c963f.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/187.150965a0.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/188.18ddb7ce.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/189.db8c9410.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/19.f8fb9afa.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/190.8cad4ae6.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/191.c4783703.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/192.8b51b235.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/193.089d9c7c.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/194.c91a988d.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/195.328c3222.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/196.a87a33a2.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/197.56e9ef5f.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/198.7b31dcb4.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/199.e4771a7d.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/20.8c83c315.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/200.fc9e8099.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/201.7a29c009.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/202.9ca31c4b.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/203.f2992d18.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/204.f69ab40f.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/205.bfcdc5c3.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/206.4cdeb457.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/207.84e1b226.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/208.9ba66a81.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/209.695b560b.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/21.e4501a72.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/210.bab2ce3a.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/211.9ed399d2.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/212.4a59cf0b.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/213.3213ab69.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/214.e2d27758.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/215.44dd0494.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/216.d588a0e7.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/217.b3115c3b.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/218.99036c0d.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/219.539b576f.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/22.14e01a8c.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/220.e99e9e74.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/221.ae44b15a.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/222.47aa5e73.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/223.3c6f8ccc.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/224.11342c05.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/225.f336bc1b.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/226.966a9ec1.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/227.8c29ace7.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/228.ae3f8c61.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/229.2b638144.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/23.1e8762ae.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/230.9a50072f.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/231.cfce61c3.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/232.dc1a3029.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/233.c3a2e2b1.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/234.444a60c4.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/235.45585d31.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/236.64cf729c.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/237.291629f7.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/238.24fa9f13.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/24.70b7bdbe.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/25.bd070c54.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/26.ebb5e627.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/27.7a26c6a1.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/28.596acb09.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/29.ee13f6e7.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/30.55d388e0.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/31.9b20d9c5.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/32.c6174017.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/33.f2d9d7ce.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/34.65548536.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/35.d0579344.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/36.d15abced.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/37.57517b1e.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/38.ed82deee.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/39.c114628e.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/4.3885dcec.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/40.dc064542.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/41.1e2e7954.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/42.ab3984e0.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/43.9d1b0700.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/44.3bd3d59e.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/45.9c6ec5e7.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/46.7752e7cf.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/47.c16b88a4.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/48.9e3be3ce.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/49.6fdf9870.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/5.43d6e46b.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/50.b6bc7bb8.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/51.e4db1a14.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/52.f93e3f90.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/53.6f931734.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/54.34e4b327.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/55.db1790ce.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/56.1a305926.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/58.3ec0e91a.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/59.9219828d.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/6.046616de.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/60.500142b2.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/61.b0902cef.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/62.7b6e7b71.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/63.eec1ee38.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/64.d67f20a4.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/65.8606b297.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/66.1a75296f.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/67.733a2d77.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/68.59e1f87c.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/69.01bca8c3.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/7.8cc99092.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/70.513c197e.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/71.24b8c4e8.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/72.401211a9.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/73.c684ba73.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/74.ff229d15.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/75.5c30ac36.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/76.a07bab0a.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/77.63daa4fb.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/78.ce06eb07.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/79.956e0f8f.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/8.03fab746.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/80.77ed2ae4.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/81.f27aa2c8.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/82.29b356ed.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/83.a5f8e4d4.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/84.1acac176.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/85.5ece69b9.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/86.3f508fec.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/87.8a5110c8.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/88.17e58eb5.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/89.71a5429f.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/9.53a33775.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/90.5576608c.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/91.d7a89fdb.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/92.41adc2d0.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/93.70695585.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/94.3aaecefa.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/95.70833a2f.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/96.f00009fd.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/97.b5420095.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/98.b3e12fd1.js"><link rel="prefetch" href="/vuepress-theme-vdoing/assets/js/99.44b3a2d2.js">
    <link rel="stylesheet" href="/vuepress-theme-vdoing/assets/css/0.styles.d4b58c13.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/vuepress-theme-vdoing/" class="home-link router-link-active"><img src="/vuepress-theme-vdoing/img/logo.png" alt="卢晓凯博客" class="logo"> <span class="site-name can-hide">卢晓凯博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/vuepress-theme-vdoing/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端" class="dropdown-title"><a href="/vuepress-theme-vdoing/web/" class="link-title">前端</a> <span class="title" style="display:none;">前端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>前端文章</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/vuepress-theme-vdoing/pages/8143cc480faf9a11/" class="nav-link">JavaScript</a></li></ul></li><li class="dropdown-item"><h4>学习笔记</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/vuepress-theme-vdoing/note/javascript/" class="nav-link">《JavaScript教程》</a></li><li class="dropdown-subitem"><a href="/vuepress-theme-vdoing/note/js/" class="nav-link">《JavaScript高级程序设计》</a></li><li class="dropdown-subitem"><a href="/vuepress-theme-vdoing/note/es6/" class="nav-link">《ES6 教程》</a></li><li class="dropdown-subitem"><a href="/vuepress-theme-vdoing/note/vue/" class="nav-link">《Vue》</a></li><li class="dropdown-subitem"><a href="/vuepress-theme-vdoing/note/react/" class="nav-link">《React》</a></li><li class="dropdown-subitem"><a href="/vuepress-theme-vdoing/note/typescript-axios/" class="nav-link">《TypeScript 从零实现 axios》</a></li><li class="dropdown-subitem"><a href="/vuepress-theme-vdoing/note/git/" class="nav-link">《Git》</a></li><li class="dropdown-subitem"><a href="/vuepress-theme-vdoing/pages/51afd6/" class="nav-link">TypeScript</a></li><li class="dropdown-subitem"><a href="/vuepress-theme-vdoing/pages/4643cd/" class="nav-link">JS设计模式总结</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="页面" class="dropdown-title"><a href="/vuepress-theme-vdoing/ui/" class="link-title">页面</a> <span class="title" style="display:none;">页面</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vuepress-theme-vdoing/pages/8309a5b876fc95e3/" class="nav-link">HTML</a></li><li class="dropdown-item"><!----> <a href="/vuepress-theme-vdoing/pages/0a83b083bdf257cb/" class="nav-link">CSS</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="技术" class="dropdown-title"><a href="/vuepress-theme-vdoing/technology/" class="link-title">技术</a> <span class="title" style="display:none;">技术</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vuepress-theme-vdoing/pages/9a7ee40fc232253e/" class="nav-link">技术文档</a></li><li class="dropdown-item"><!----> <a href="/vuepress-theme-vdoing/pages/4c778760be26d8b3/" class="nav-link">GitHub技巧</a></li><li class="dropdown-item"><!----> <a href="/vuepress-theme-vdoing/pages/117708e0af7f0bd9/" class="nav-link">Nodejs</a></li><li class="dropdown-item"><!----> <a href="/vuepress-theme-vdoing/pages/41f87d890d0a02af/" class="nav-link">博客搭建</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="更多" class="dropdown-title"><a href="/vuepress-theme-vdoing/more/" class="link-title">更多</a> <span class="title" style="display:none;">更多</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vuepress-theme-vdoing/pages/f2a556/" class="nav-link">学习</a></li><li class="dropdown-item"><!----> <a href="/vuepress-theme-vdoing/pages/aea6571b7a8bae86/" class="nav-link">面试</a></li><li class="dropdown-item"><!----> <a href="/vuepress-theme-vdoing/pages/2d615df9a36a98ed/" class="nav-link">心情杂货</a></li><li class="dropdown-item"><!----> <a href="/vuepress-theme-vdoing/pages/baaa02/" class="nav-link">实用技巧</a></li><li class="dropdown-item"><!----> <a href="/vuepress-theme-vdoing/friends/" class="nav-link">友情链接</a></li></ul></div></div><div class="nav-item"><a href="/vuepress-theme-vdoing/about/" class="nav-link">关于</a></div><div class="nav-item"><a href="/vuepress-theme-vdoing/pages/beb6c0bd8a66cea6/" class="nav-link">收藏</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/vuepress-theme-vdoing/archives/" class="link-title">索引</a> <span class="title" style="display:none;">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vuepress-theme-vdoing/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/vuepress-theme-vdoing/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/vuepress-theme-vdoing/archives/" class="nav-link">归档</a></li></ul></div></div> <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><div class="blogger"><img src="https://cdn.jsdelivr.net/gh/xugaoyi/image_store/blog/20200103123203.jpg"> <div class="blogger-info"><h3>XiaoKai Lu</h3> <span>java开发</span></div></div> <nav class="nav-links"><div class="nav-item"><a href="/vuepress-theme-vdoing/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端" class="dropdown-title"><a href="/vuepress-theme-vdoing/web/" class="link-title">前端</a> <span class="title" style="display:none;">前端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>前端文章</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/vuepress-theme-vdoing/pages/8143cc480faf9a11/" class="nav-link">JavaScript</a></li></ul></li><li class="dropdown-item"><h4>学习笔记</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/vuepress-theme-vdoing/note/javascript/" class="nav-link">《JavaScript教程》</a></li><li class="dropdown-subitem"><a href="/vuepress-theme-vdoing/note/js/" class="nav-link">《JavaScript高级程序设计》</a></li><li class="dropdown-subitem"><a href="/vuepress-theme-vdoing/note/es6/" class="nav-link">《ES6 教程》</a></li><li class="dropdown-subitem"><a href="/vuepress-theme-vdoing/note/vue/" class="nav-link">《Vue》</a></li><li class="dropdown-subitem"><a href="/vuepress-theme-vdoing/note/react/" class="nav-link">《React》</a></li><li class="dropdown-subitem"><a href="/vuepress-theme-vdoing/note/typescript-axios/" class="nav-link">《TypeScript 从零实现 axios》</a></li><li class="dropdown-subitem"><a href="/vuepress-theme-vdoing/note/git/" class="nav-link">《Git》</a></li><li class="dropdown-subitem"><a href="/vuepress-theme-vdoing/pages/51afd6/" class="nav-link">TypeScript</a></li><li class="dropdown-subitem"><a href="/vuepress-theme-vdoing/pages/4643cd/" class="nav-link">JS设计模式总结</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="页面" class="dropdown-title"><a href="/vuepress-theme-vdoing/ui/" class="link-title">页面</a> <span class="title" style="display:none;">页面</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vuepress-theme-vdoing/pages/8309a5b876fc95e3/" class="nav-link">HTML</a></li><li class="dropdown-item"><!----> <a href="/vuepress-theme-vdoing/pages/0a83b083bdf257cb/" class="nav-link">CSS</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="技术" class="dropdown-title"><a href="/vuepress-theme-vdoing/technology/" class="link-title">技术</a> <span class="title" style="display:none;">技术</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vuepress-theme-vdoing/pages/9a7ee40fc232253e/" class="nav-link">技术文档</a></li><li class="dropdown-item"><!----> <a href="/vuepress-theme-vdoing/pages/4c778760be26d8b3/" class="nav-link">GitHub技巧</a></li><li class="dropdown-item"><!----> <a href="/vuepress-theme-vdoing/pages/117708e0af7f0bd9/" class="nav-link">Nodejs</a></li><li class="dropdown-item"><!----> <a href="/vuepress-theme-vdoing/pages/41f87d890d0a02af/" class="nav-link">博客搭建</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="更多" class="dropdown-title"><a href="/vuepress-theme-vdoing/more/" class="link-title">更多</a> <span class="title" style="display:none;">更多</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vuepress-theme-vdoing/pages/f2a556/" class="nav-link">学习</a></li><li class="dropdown-item"><!----> <a href="/vuepress-theme-vdoing/pages/aea6571b7a8bae86/" class="nav-link">面试</a></li><li class="dropdown-item"><!----> <a href="/vuepress-theme-vdoing/pages/2d615df9a36a98ed/" class="nav-link">心情杂货</a></li><li class="dropdown-item"><!----> <a href="/vuepress-theme-vdoing/pages/baaa02/" class="nav-link">实用技巧</a></li><li class="dropdown-item"><!----> <a href="/vuepress-theme-vdoing/friends/" class="nav-link">友情链接</a></li></ul></div></div><div class="nav-item"><a href="/vuepress-theme-vdoing/about/" class="nav-link">关于</a></div><div class="nav-item"><a href="/vuepress-theme-vdoing/pages/beb6c0bd8a66cea6/" class="nav-link">收藏</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/vuepress-theme-vdoing/archives/" class="link-title">索引</a> <span class="title" style="display:none;">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vuepress-theme-vdoing/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/vuepress-theme-vdoing/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/vuepress-theme-vdoing/archives/" class="nav-link">归档</a></li></ul></div></div> <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>技术文档</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/vuepress-theme-vdoing/pages/9a7ee40fc232253e/" class="sidebar-link">Git使用手册</a></li><li><a href="/vuepress-theme-vdoing/pages/ad247c4332211551/" class="sidebar-link">Markdown使用教程</a></li><li><a href="/vuepress-theme-vdoing/pages/61f2f95fd7da14fd/" class="sidebar-link">npm常用命令</a></li><li><a href="/vuepress-theme-vdoing/pages/dec4f3f00e71a312/" class="sidebar-link">npm packageJson属性详解</a></li><li><a href="/vuepress-theme-vdoing/pages/4e8444e2d534d14f/" class="sidebar-link">yaml语言教程</a></li><li><a href="/vuepress-theme-vdoing/pages/df4715/" aria-current="page" class="active sidebar-link">Spring源码分析</a><ul class="sidebar-sub-headers"></ul></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>GitHub技巧</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Nodejs</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>博客搭建</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-1baff76c><div class="articleInfo" data-v-1baff76c><ul class="breadcrumbs" data-v-1baff76c><li data-v-1baff76c><a href="/vuepress-theme-vdoing/" title="首页" class="iconfont icon-home router-link-active" data-v-1baff76c></a></li> <li data-v-1baff76c><a href="/vuepress-theme-vdoing/technology/#技术" data-v-1baff76c>技术</a></li><li data-v-1baff76c><a href="/vuepress-theme-vdoing/technology/#技术文档" data-v-1baff76c>技术文档</a></li></ul> <div class="info" data-v-1baff76c><div title="作者" class="author iconfont icon-touxiang" data-v-1baff76c><a href="https://github.com/xugaoyi" target="_blank" title="作者" class="beLink" data-v-1baff76c>xugaoyi</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-1baff76c><a href="javascript:;" data-v-1baff76c>2022-05-20</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABKFJREFUSA3tVl1oFVcQnrMbrak3QUgkya1akpJYcrUtIqW1JvFBE9LiQ5v6JmJpolbMg32rVrhgoYK0QiMY6i9Y6EMaW5D+xFJaTYItIuK2Kr3+BJNwkxBj05sQY3b3nM6cs2dv9t7NT/vQJw/sndk5M/PNzJkzewGerP+pAmy+ON8lLzUJgA8ZYxYIYZmGYRnctDaWvJJAmTtfP1pvXsBCCPP8QFcCaRkZYACgDZFO4stNIcBCajEOlmmC9XpJ9bAGCaPaPmzPl32dvLSVu3BWCTQs0XQQ6g0DYgwLIoAZbBCdW/i+781o1VVlm/410mw4h06Y7bIPHNyWDyL4FHkX03Q8SrzNhZTZriieckWt7cL6MM85YcLpsi/7O9/iXFT6MswI0DmmpkSaJ0qLxFIm3+i1THHB3zmBH3PYx9CcykcLOeQVVa7QtdxTgQgEleX2AjHYfwA+2ddV77ruGoJUbhGDI09YSNXyMpUt5ylOzxgbUmtOp7NmbNt8v3arjTBfYELmLUV+M+nSawNNAUqpT3ClJWg5I3BLT+cGW/DXNGCa6tx1aakCGEigArTn4TDIPdrXXYKCZNrHLMCOEPvHBlLQ99s9eHB7EB6NTki73CVPQ2F5MSx/uRQixfmq7rK0wYD8w8E905bnPDfwoWs/rfv93NWN/ZfvwsLIU7A09gxECyISeGJkHAau98L97tuw7NXnoPyNF8FcYGLGKsOs0mN3OEyec9esGW/ZEl945dTP34wlR2FZVQWU1q0Cw8Tr7p+hgLLNL0FPxx/Q35mA8aEUrH6nCgwEl0tn7wUiZYJnNRh6DK4UH/k0lfyrsBKdPVv/AriGIQcEDQZ65LBAGe2Rzui9Ybjz7XUppz1/uKBbyVPGkN3ZAeC6hr0x7Nr38N5+EqkoOm17xpoqR9ohQF55ERSvr4Dkr3chNfC3DMzGJlNBElW8w9nsGQvhNGIzDkXzCg8cLK951xHsFBlTJspJNi3ZFIMF2AeDV3q8DNOB+YHi6QTrChDIWDBRi5U5f+ZMfJLu3ccrqxtdxk4SKH336LFxSmkqefwU5T8fhdSdQf9IVKD6aNiwI/hnmcAZ91isYMJIaCUCx9W098+LgruikeTqzqqxKPUwqJyCPJiyemVVZBOijDGjD38Os0jOiSPL1z3SPjXNANbiNPXAdzTfukjjuknNBbyz3nwgTd3AVFqUJ5hpHlq9MveLnWwttUfoygBmvVjuikxND3znrhsELnZk7k+OjIGxeNEkomyLVta0xxn+HZhjBc4YZ/AFjHjz9u3xRZl2BN4aq9nFwWh16IrQ1aHHEd3j1+4/dB9OtH4e29A2H1DyHQRmOSfQZ1Fy7MHBTGB6J/Djq6p3OxyO2cB+4Car7v/o3GXgfAkj23+x9ID1Teoamo/SXcbvSf2PX7Vc8DdCmE1vN9di+32P9/5YR3vLnhCVGUWBjEkr3yh4H8v9CzmsbdhzOKzsJKM90iFdaTMjRPhGVsakRvOaRidljo6H6G7j+ctrJpsP+4COhDIl0La2+FS4+5mlocBaXY5QnGZysIBYoeSsl5qQzrSj/cgNrfuEzlWBfwA+EjrZyWUvpAAAAABJRU5ErkJggg==">Spring源码分析<!----></h1>  <div class="theme-vdoing-content content__default"><h1 id="spring源码分析"><a href="#spring源码分析" class="header-anchor">#</a> Spring源码分析</h1> <h3 id="_1-spring应用"><a href="#_1-spring应用" class="header-anchor">#</a> 1 .spring应用</h3> <h4 id="_1-1-spring声明bean的方式有哪些"><a href="#_1-1-spring声明bean的方式有哪些" class="header-anchor">#</a> 1.1 spring声明Bean的方式有哪些？</h4> <p>声明式：</p> <p>xml</p> <p>@Bean，@Component</p> <p>编程式</p> <p>applicationContext.registerBean();</p> <h4 id="_1-2-spring的注入方式有哪些"><a href="#_1-2-spring的注入方式有哪些" class="header-anchor">#</a> 1.2 spring的注入方式有哪些？</h4> <p>构造方法注入</p> <p>setter方法注入</p> <h4 id="_1-3-spring的注入模型有哪些"><a href="#_1-3-spring的注入模型有哪些" class="header-anchor">#</a> 1.3 spring的注入模型有哪些？</h4> <p>no：不注入</p> <p>byType：通过类型</p> <p>byName：通过名字</p> <p>constructor ：通过构造函数</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>构造方法注入的方式,只能通过constructor注入模型去注入

setter注入的方式,可以通过byType,byName这两种注入模型去注入
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>spring的自动装配（自动注入）</p> <p>其实spring的自动装配（自动注入）是针对xml配置的情况下说的</p> <p>解释：定义一个bean，里面又依赖某个bean,在没有对这个依赖bean做任何注入的时候，如果对这个定义bean，指定某种自动装配。那么Spring会根据自动装配模型，通过setter方法或构造函数，进行属性填充。</p> <p>例如：byName</p> <p><img src="https://img-blog.csdnimg.cn/2019120221060660.png" alt="img"></p> <p>例如：byType</p> <p><img src="https://img-blog.csdnimg.cn/20191202210643558.png" alt="img"></p> <p>需要在定义的bean中，定义相应的setter方法</p> <h4 id="_1-4-autowired与自动装配"><a href="#_1-4-autowired与自动装配" class="header-anchor">#</a> 1.4 @Autowired与自动装配</h4> <p>@Autowired先通过类型去匹配，再根据名字去匹配。</p> <p><strong>这里可以思考一下，为什么先通过类型去匹配，再根据名字去匹配？</strong></p> <p>因为在spring的单例池中beanName是作为key的，也就是唯一的，如果直接根据byName去找有可能找到的Bean并不是你预想的那个Bean（例如想@Autowired orderService，但是可能UserService这个类在注入spring时，使用的beanName是orderService），所以必须要现根据要注入的属性的Type去找，找到一个直接注入，找到多个再根据byName去注入</p> <p>在实际开发中，我们没有指定bean的自动装配模型，大多数都是在需要依赖属性上面加上@Autowired注解。无需多余代码，Spring也会把这个依赖属性完成填充。那是不是说明加了@Autowired注解就说明我们这个bean就是自动装配了呢。其实不然，通过源码，可以看到，@Autowired注解是调用了bean的后置处理器AutowiredAnnotationBeanPostProcessor的postProcessProperties方法完成属性注入。方法的核心其实就是运用java反射技术，field.set(object,args);</p> <p><img src="https://img-blog.csdnimg.cn/20191202204858568.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0x1b1FpYW5nUWlhbmcyMDE3,size_16,color_FFFFFF,t_70" alt="img"></p> <p>这个跟bean注入模型不对应，bean的注入模型分为byType,和byName,constructor。基于setter方法和构造函数，而在spring源码中对于@Autowired注解是通过java反射的技术完成的。</p> <h4 id="_1-5-autowired与-resource"><a href="#_1-5-autowired与-resource" class="header-anchor">#</a> 1.5 @Autowired与@Resource</h4> <p>两者的包不同，@Resource是 javax.annotation包下的，归属于jdk;@Autowire是 org.springframework.beans.factory.annotation包下的，归属于Spring。
两者完成属性注入时使用的bean的后置处理器不同。@Resource 是用CommonAnnotationBeanPostProcessor.postProcessProperties()方法，@Autowire则是AutowiredAnnotationBeanPostProcessor bean后置处理器来完成属性注入。</p> <p>一般在开发中不建议使用@Resource，@Resource注入时是直接使用byName模型的，有可能会与预期注入的bean不一样。</p> <h4 id="_1-6-如何将一个对象放入spring容器中"><a href="#_1-6-如何将一个对象放入spring容器中" class="header-anchor">#</a> 1.6 如何将一个对象放入spring容器中</h4> <p>注意：是对象交给spring管理而不是类交给spring管理</p> <ol><li><p>@Bean</p></li> <li><p>FactoryBean</p></li> <li><p>getBeanFactory().registerSingleton()</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>其中第三种方法，只是将对象交给spring处理，但是此对象的依赖spring并不会管理，需要手动管理

因为此对象是自己手动new出来的，无论在spring容器初始化完成后，还是初始化完成前他都不会经过springBean的生命周期
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div></li></ol> <h4 id="_1-7-bean的初始化与销毁"><a href="#_1-7-bean的初始化与销毁" class="header-anchor">#</a> 1.7 Bean的初始化与销毁</h4> <p>如何在Bean初始化完成后，立即执行一些操作？</p> <ol><li><p>@PostConstruct</p></li> <li><p>实现InitializingBean的afterPropertiesSet方法</p></li> <li><p>xml配置bean时，指定init-method属性</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>这三种方法是有先后顺序的
如果这三种全部都配置了，那么执行顺序是：1---&gt;2---&gt;3
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></li></ol> <p>销毁：</p> <ol><li>DisposableBean/AutoCloseable</li> <li>BeanDefinition中定义了destroyMethodName</li> <li>@PreDestroy</li> <li>如果是@Bean方式注入spring，类中存在close或者shutdown方法</li></ol> <h4 id="_1-8-spring容器初始化"><a href="#_1-8-spring容器初始化" class="header-anchor">#</a> 1.8 spring容器初始化</h4> <p>如何在spring容器启动后，停止前做一些自定义的操作？</p> <ol><li><p>实现 SmartLifecycle接口</p></li> <li><p>实现Lifecycle接口</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>SmartLifecycle接口是继承了Lifecycle接口的，所以一般情况下用第一种方式
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li></ol> <h4 id="_1-9-代理"><a href="#_1-9-代理" class="header-anchor">#</a> 1.9 代理</h4> <h5 id="静态代理"><a href="#静态代理" class="header-anchor">#</a> 静态代理</h5> <p>静态代理比较简单，有.java，.class文件，是可以看到的。</p> <p>Api类</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>kai<span class="token punctuation">.</span>proxy<span class="token punctuation">.</span>statics</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Api</span> <span class="token punctuation">{</span>

	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>Target类</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>kai<span class="token punctuation">.</span>proxy<span class="token punctuation">.</span>statics</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Target</span> <span class="token keyword">implements</span> <span class="token class-name">Api</span><span class="token punctuation">{</span>

	<span class="token annotation punctuation">@Override</span>
	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Target</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getSimpleName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot; sayHi。。。&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>Proxy类</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>kai<span class="token punctuation">.</span>proxy<span class="token punctuation">.</span>statics</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Proxy</span> <span class="token keyword">implements</span> <span class="token class-name">Api</span> <span class="token punctuation">{</span>
	<span class="token keyword">private</span> <span class="token class-name">Target</span> target<span class="token punctuation">;</span>

	<span class="token keyword">public</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span><span class="token class-name">Target</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">this</span><span class="token punctuation">.</span>target <span class="token operator">=</span> target<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token annotation punctuation">@Override</span>
	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token comment">//执行代理对象逻辑</span>
		<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Proxy begin。。。&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">//执行目标对象的方法</span>
		target<span class="token punctuation">.</span><span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">//执行代理对象逻辑</span>
		<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Proxy end。。。&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p>Main类</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>kai<span class="token punctuation">.</span>proxy<span class="token punctuation">.</span>statics</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>
	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token class-name">Target</span> target <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Target</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token class-name">Proxy</span> proxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span>
		proxy<span class="token punctuation">.</span><span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h5 id="动态代理"><a href="#动态代理" class="header-anchor">#</a> 动态代理</h5> <ol><li>jdk动态代理</li> <li>cglib动态代理</li></ol> <p>动态代理的代理对象没有.java，.class文件，直接就是生成的字节码对象并被ClassLoader加载到jvm内存中</p> <ol><li>Spring 5.x 中 AOP 默认依旧使用 JDK 动态代理。</li> <li>SpringBoot 2.x 开始，为了解决使用 JDK 动态代理可能导致的类型转化异常而默认使用 CGLIB。</li> <li>在 SpringBoot 2.x 中，如果需要默认使用 JDK 动态代理可以通过配置项<code>spring.aop.proxy-target-class=false</code>来进行修改，<code>proxyTargetClass</code>配置已无效</li></ol> <h4 id="_1-10-aop"><a href="#_1-10-aop" class="header-anchor">#</a> 1.10 AOP</h4> <ol><li>Aspect</li></ol> <div class="language- line-numbers-mode"><pre class="language-text"><code>Aspect：切面
用官方文档的话来说就是一个横切关注点模块化，切面就和spring的容器一样，是多个组件组合在一起就叫做切面。
可以简单地认为, 使用 @Aspect 注解的类就是切面
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ol><li>Join point</li></ol> <div class="language- line-numbers-mode"><pre class="language-text"><code>Join point：连接点
程序执行期间切点的一个点，如方法执行或异常处理期间的一个点。（具体哪个方法才会执行Advice）
简单来说，连接点就是被拦截到的程序执行点，因为Spring只支持方法类型的连接点，所以在Spring中连接点就是被拦截到的方法。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ol><li>Advice</li></ol> <div class="language- line-numbers-mode"><pre class="language-text"><code>Advice：通知，代理逻辑
代理逻辑是指拦截到连接点之后要执行的代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><ol><li>Pointcut</li></ol> <div class="language- line-numbers-mode"><pre class="language-text"><code> Pointcut：切点
 切点是对连接点进行拦截的条件定义，是连接点的集合
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><ol><li>advisor</li></ol> <div class="language- line-numbers-mode"><pre class="language-text"><code>advisor = advice + PointCut
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ol><li>Introduction</li></ol> <div class="language- line-numbers-mode"><pre class="language-text"><code>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ol><li>Target object</li></ol> <div class="language- line-numbers-mode"><pre class="language-text"><code>Target object：目标对象
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ol><li>AOP proxy</li></ol> <div class="language- line-numbers-mode"><pre class="language-text"><code> AOP proxy：代理对象
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ol><li>Weaving</li></ol> <div class="language- line-numbers-mode"><pre class="language-text"><code>Weaving：织入
织入是将切面和业务逻辑对象连接起来, 并创建通知代理的过程。织入可以在编译时，类加载时和运行时完成。在编译时进行织入就是静态代理，而在运行时进行织入则是动态代理。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="_2-spring源码解析"><a href="#_2-spring源码解析" class="header-anchor">#</a> 2.spring源码解析</h3> <h4 id="_2-1-1-beandeinintion-bean定义"><a href="#_2-1-1-beandeinintion-bean定义" class="header-anchor">#</a> 2.1.1 BeanDeinintion（Bean定义）</h4> <p>spring中对于类中是否加入了类似@Comment，@Lazy。。。的注解，使用的是AMS字节码技术判断的</p> <p><strong>为什么spring中需要将Bean包装为BeanDefinition？</strong></p> <p>在spring中对于一个Bean的解析只会做一次，需要将Bean的一些属性进行缓存，例如是否为单例，是否为懒加载，beanClass，beanName。。。。，想要将属性进行缓存，必然需要一个类对Bean进行包装，BeanDefinition就是做这个工作的</p> <p><strong>试想一下，如果没有BeanDefinition，会出现什么现象？</strong></p> <p>首先，因为Bean属性没有缓存，在加载Bean的时候，解析了一次类的属性，在走Bean声明周期，生成Bean对象的时候又解析一次类的属性，getBean时，还需要解析一次。。。。。。</p> <h4 id="_2-1-2-beandefinitionreader"><a href="#_2-1-2-beandefinitionreader" class="header-anchor">#</a> 2.1.2 BeanDefinitionReader</h4> <p>负责读取BeanDefinition的接口，传入单个的类，将类读取，解析成为一个BeanDefinition。传入的类不必要加@Comonent，但是一些Bean属性（lazy，scope。。。）的注解还是需要加的</p> <h4 id="_2-1-3-beandefinitionregisty"><a href="#_2-1-3-beandefinitionregisty" class="header-anchor">#</a> 2.1.3 BeanDefinitionRegisty</h4> <p>负责注册，存放BeanDefinition的接口</p> <h4 id="_2-1-4-classpathbeandefinitionscanner"><a href="#_2-1-4-classpathbeandefinitionscanner" class="header-anchor">#</a> 2.1.4 ClassPathBeanDefinitionScanner</h4> <p>负责扫描给定包下面加了@Commonent，@Service。。。但是不包括@Bean的类，并封装成为BeanDefinition</p> <h4 id="_2-1-5-metadatareader"><a href="#_2-1-5-metadatareader" class="header-anchor">#</a> 2.1.5 MetadataReader</h4> <p>负责读取Class的元数据以及被注解的元数据，并封装为Metadata并作为BeanDefinition的一个属性</p> <h4 id="_2-1-6-annotationawareordercomparator"><a href="#_2-1-6-annotationawareordercomparator" class="header-anchor">#</a> 2.1.6 AnnotationAwareOrderComparator</h4> <p>spring提供的比较器，主要用来对List集合中的元素针对（@Order注解的值，@Priority的值，Ordered接口）进行排序，可以单独使用，不必在spring环境中</p> <h4 id="_2-1-7-beanfactory"><a href="#_2-1-7-beanfactory" class="header-anchor">#</a> 2.1.7 BeanFactory</h4> <p>Bean工厂接口，负责生成Bean，获取Bean</p> <p>有许多实现类，各个实现类负责一部分Bean工厂的功能</p> <p>比较核心的实现类为DefaultListableBeanFactory</p> <p>上面这些使用下面的图来联系起来看比较容易理解</p> <p><img src="https://gitee.com/lxk_kaige/blogImage/raw/master/img/image-20201012090823502.png" alt="image-20201012090823502"></p> <p>BeanFactory：顶级接口，提供了获取bean，是否存在bean，是否为单例bean等方法</p> <p>ListableBeanFactory：派生接口，提供了一些关于BeanDefinition的方法以及其他方式获取Bean，例如是否包含bd，获取bd的数量，获取所有bd的名字，以及根据类型获取Bean。。。</p> <p>HierarchicalBeanFactory：派生接口，提供获取父Bean工厂的方法</p> <p>。。。</p> <p>根据每个接口的名字，就可以大概看出每个接口负责的功能</p> <p>可以看到DefaultListableBeanFactory实现的各个顶级接口有BeanFactory，BeanDefinitionRegistry，说明DefaultListableBeanFactory拥有BeanDefinition的存放以及注册，生成Bean，获取Bean等关于Bean的操作的功能</p> <h4 id="factorybean"><a href="#factorybean" class="header-anchor">#</a> FactoryBean</h4> <blockquote><p><strong>FactoryBean工厂本身会存在单例池中，而getObject()返回的对象会存在factoryBeanObjectCache中</strong></p></blockquote> <p>FactoryBean为一个生产Bean的工厂类，他在spring中是一个特殊的Bean，会生成两个Bean，一个getObject()返回的对象，一个FactoryBean本身</p> <p>当使用@Autowired注入FactoryBean的beanName时，spring会注入getObject()返回的Bean</p> <p>当使用@Autowired注入实现FactoryBean传入的泛型类时（public class MyFactoryBean implements FactoryBean ），@Autowired 开始的byType会将当前实现了FactoryBean的Bean也加入候选，最终根据byName决定最终使用哪个。</p> <p>如果想注入factoryBean本身，需要加上&amp;</p> <p>FactoryBean，实际上是懒加载，但是有一个实现类SmartFactoryBean，可以变为非懒加载，启动时创建此Bean</p> <h4 id="aware"><a href="#aware" class="header-anchor">#</a> Aware</h4> <p>spring提供的回调接口，有多个实现类，例如BeanNameAware，BeanFactoryAware。。。</p> <p>当一个Bean初始化已经完成后，如果实现了Aware接口，就会回调此接口的方法</p> <h4 id="解析配置类以及扫描源码解析"><a href="#解析配置类以及扫描源码解析" class="header-anchor">#</a> 解析配置类以及扫描源码解析</h4> <p>首先分析一下spring中BeanDefinitionRegistryPostProcessor以及BeanFactoryPostProcessor两个类的执行过程</p> <p>BeanDefinitionRegistryPostProcessor为BeanFactoryPostProcessor的子类</p> <h4 id="执行beanfactorypostprocessor"><a href="#执行beanfactorypostprocessor" class="header-anchor">#</a> 执行BeanFactoryPostProcessor</h4> <ol><li>执行通过ApplicationContext添加进来的BeanDefinitionRegistryPostProcessor的postProcessBeanDefinitionRegistry()方法</li> <li>执行BeanFactory中实现了PriorityOrdered接口的BeanDefinitionRegistryPostProcessor的postProcessBeanDefinitionRegistry()方法</li> <li>执行BeanFactory中实现了Ordered接口的BeanDefinitionRegistryPostProcessor的postProcessBeanDefinitionRegistry()方法</li> <li>执行BeanFactory中其他的BeanDefinitionRegistryPostProcessor的postProcessBeanDefinitionRegistry()方法</li> <li>执行上面所有的BeanDefinitionRegistryPostProcessor的postProcessBeanFactory()方法</li> <li>执行通过ApplicationContext添加进来的BeanFactoryPostProcessor的postProcessBeanFactory()方法</li> <li>执行BeanFactory中实现了PriorityOrdered接口的BeanFactoryPostProcessor的postProcessBeanFactory()方法</li> <li>执行BeanFactory中实现了Ordered接口的BeanFactoryPostProcessor的postProcessBeanFactory()方法</li> <li>执行BeanFactory中其他的BeanFactoryPostProcessor的postProcessBeanFactory()方法</li></ol> <h4 id="解析配置类"><a href="#解析配置类" class="header-anchor">#</a> 解析配置类</h4> <p>spring中配置类的解析与扫描是org.springframework.context.annotation.ConfigurationClassPostProcessor#postProcessBeanDefinitionRegistry来完成的，执行时机就在第2步中，主要的功能为（筛选配置类，处理扫描ComponentScan，处理import，处理@Bean。。。）并注册成为BeanDefinition</p> <p><img src="https://gitee.com/lxk_kaige/blogImage/raw/master/img/Spring%E9%85%8D%E7%BD%AE%E7%B1%BB%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B.png" alt="Spring配置类解析流程.png"></p> <ol><li><p>在启动Spring时，需要传入一个AppConfig.class给ApplicationContext，ApplicationContext会根据AppConfig类封装为一个BeanDefinition，这种BeanDefinition我们把它称为配置类BeanDefinition。</p></li> <li><p>ConfigurationClassPostProcessor中会把配置类BeanDefinition取出来</p></li> <li><p>构造一个ConfigurationClassParser用来解析配置类BeanDefinition，并且会生成一个配置类对象ConfigurationClass</p></li> <li><p>如果配置类上存在@Component注解，那么<strong>解析配置类中的内部类（这里有递归，如果内部类也是配置类的话）</strong></p></li> <li><p>如果配置类上存在@PropertySource注解，那么则解析该注解，并得到PropertySource对象，并添加到environment中去</p></li> <li><p>如果配置类上存在@ComponentScan注解，那么则解析该注解，进行扫描，扫描得到一系列的BeanDefinition对象，然后判断这些BeanDefinition是不是也是配置类BeanDefinition（只要存在@Component注解就是配置类，所以基本上扫描出来的都是配置类），如果是则继续解析该配置类，<strong>（也有递归）</strong>，并且会生成对应的ConfigurationClass</p></li> <li><p>如果配置类上存在@Import注解，那么则判断Import的类的类型：</p></li> <li><ol><li>如果是ImportSelector，那么调用执行selectImports方法得到类名，然后在把这个类当做配置类进行解析**（也是递归）**</li></ol></li> <li><p>如果是ImportBeanDefinitionRegistrar，那么则生成一个ImportBeanDefinitionRegistrar实例对象，并添加到配置类对象中（ConfigurationClass）的<strong>importBeanDefinitionRegistrars</strong>属性中。</p></li> <li><p>如果配置类上存在@ImportResource注解，那么则把导入进来的资源路径存在配置类对象中的<strong>importedResources</strong>属性中。</p></li> <li><p>如果配置类中存在@Bean的方法，那么则把这些方法封装为BeanMethod对象，并添加到配置类对象中的<strong>beanMethods</strong>属性中。</p></li> <li><p>如果配置类实现了某些接口，则看这些接口内是否定义了@Bean的默认方法</p></li> <li><p>如果配置类有父类，则把父类当做配置类进行解析</p></li> <li><p>AppConfig这个配置类会对应一个ConfigurationClass，同时在解析的过程中也会生成另外的一些ConfigurationClass，接下来就利用reader来进一步解析ConfigurationClass</p></li> <li><ol><li>如果ConfigurationClass是通过@Import注解导入进来的，则把这个类生成一个BeanDefinition，同时解析这个类上@Scope,@Lazy等注解信息，并注册BeanDefinition</li></ol></li> <li><p>如果ConfigurationClass中存在一些BeanMethod，也就是定义了一些@Bean，那么则解析这些@Bean，并生成对应的BeanDefinition，并注册</p></li> <li><p>如果ConfigurationClass中导入了一些资源文件，比如xx.xml，那么则解析这些xx.xml文件，得到并注册BeanDefinition</p></li> <li><p>如果ConfigurationClass中导入了一些ImportBeanDefinitionRegistrar，那么则执行对应的registerBeanDefinitions进行BeanDefinition的注册</p></li></ol> <h3 id="总结一下"><a href="#总结一下" class="header-anchor">#</a> 总结一下</h3> <ol><li>解析AppConfig类，生成对应的ConfigurationClass</li> <li>再扫描，扫描到的类都会生成对应的BeanDefinition，并且同时这些类也是ConfigurationClass</li> <li>再解析ConfigurationClass的其他信息，比如@ImportResource注解的处理，@Import注解的处理，@Bean注解的处理</li></ol> <h4 id="合并beandefinition"><a href="#合并beandefinition" class="header-anchor">#</a> 合并BeanDefinition</h4> <p>在开始拿所有的BeanDefinition，并去循环getBean()时，会去合并，合并完成后，bd变为RootDeanDefinition，RootDeanDefinition不支持设置parent</p> <p>beanName ----&gt; 合并后的bdMap ------&gt; 没有 -------&gt; BeanDefinitionMap -----&gt;  有父db ------&gt;子/父generalBeanDefinition --------&gt; 合并为RootBeanDefinition</p> <p><strong>FactoryBean的生命周期详图</strong></p> <p>https://www.processon.com/view/link/5f8d340d5653bb06ef073b0e</p> <p>被@Scope(&quot;request&quot;)注解修饰的类，形成的Bean存在request.getAtrribute();中</p> <p>第一次执行BeanPostProcess时，可以通过实现对应的BeanPostProcess来打断spring接下来的创建Bean流程，说白了如果第一次调用BeanPostProcess返回不为空，就不会执行spring自带的创建Bean的流程了（例如：推断构造方法，实例化对象，依赖注入。。。）</p> <p>![Bean的生命周期流程 (2)](https://gitee.com/lxk_kaige/blogImage/raw/master/img/Bean的生命周期流程 (2).png)</p> <h4 id="autowired注入源码流程"><a href="#autowired注入源码流程" class="header-anchor">#</a> @AutoWired注入源码流程</h4> <p>@AutoWired和@Resource这些对于一个Bean完成属性填充的操作，入口方法都是org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#populateBean</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>/**
  * 完成属性填充，自动注入
  * 	第五次和第六次后置处理器的调用
  * 	InstantiationAwareBeanPostProcessor postProcessAfterInstantiation
  * 	InstantiationAwareBeanPostProcessor postProcessProperties
  *
  */
 populateBean(beanName, mbd, instanceWrapper);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p><strong>@AutoWired属性注入的大致流程：</strong></p> <ol><li><p>首先，会走第五次后置处理器的调用，执行Bean实例化后的操作InstantiationAwareBeanPostProcessor postProcessAfterInstantiation</p></li> <li><p>然后判断当前Bean的注入模型是什么byName or byType，一般来说如果没有特殊操作的话，@Autowired注入的Bean的注入模型都是No。</p></li> <li><p>如果为No，开始执行第六次后置处理器的调用，执行InstantiationAwareBeanPostProcessor的postProcessProperties</p></li> <li><p>@Autowired对应的核心InstantiationAwareBeanPostProcessor是org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor#postProcessProperties</p></li> <li><p>在AutowiredAnnotationBeanPostProcessor的postProcessProperties真正开始执行属性注入的操作</p></li> <li><p>首先去拿当前Bean的注入点，当前Bean的注入点（@Autowired，@Resource，@Value...）在第三次后置处理器调用时已经解析过，此处直接从缓存获取</p></li> <li><p>遍历每个能够注入的属性，进行注入，注入依赖 element可能是Method,也可能是Field</p></li> <li><p>处理Field的为：org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.AutowiredFieldElement#inject</p></li> <li><p>处理Method的为：org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.AutowiredMethodElement#inject</p></li> <li><p>然后开始真正处理依赖，resolveDependency（），会在后面依赖注入的源码流程着重分析。</p></li></ol> <h4 id="resource注入源码流程"><a href="#resource注入源码流程" class="header-anchor">#</a> @Resource注入源码流程</h4> <p>@Resource属性注入的过程与@AutoWired的流程有重叠的地方，真正开始处理的地方都在第六次后置处理器的执行，只不过处理@AutoWired的BeanPostProcess是AutowiredAnnotationBeanPostProcessor，而处理@Resource的BeanPostProcess是CommonAnnotationBeanPostProcessor。</p> <p>接下来分析CommonAnnotationBeanPostProcessor的postProcessProperties方法</p> <ol><li>首先去拿当前Bean的注入点（只拿@Resource），当前Bean的注入点（@Autowired，@Resource，@Value...）在第三次后置处理器调用时已经解析过，此处直接从缓存获取</li> <li>遍历每个能够注入的属性，进行注入，注入依赖 element可能是Method,也可能是Field</li> <li>处理@Rsource注入点是字段或方法的都在org.springframework.beans.factory.annotation.InjectionMetadata.InjectedElement#inject中</li> <li>具体的逻辑在org.springframework.context.annotation.CommonAnnotationBeanPostProcessor#autowireResource中</li> <li>如果使用@Resource注入一个Bean，并且根据name属性/属性名/方法名得到的beanName不存在当前beanFactory中的话，代码就会走@AutoWired的依赖注入的逻辑，先byType，再byName</li> <li>正常情况下，根据@Resource的name属性/属性名/set方法参数得到的要注入的beanName存在beanFactory中的话，直接去根据beanName得到一个bean</li></ol> <p><strong>总结：</strong></p> <p>对于@Resource：</p> <ol><li>如果@Resource注解中指定了name属性，那么则只会根据name属性的值去找bean，如果找不到则报错</li> <li>如果@Resource注解没有指定name属性，那么会先判断当前注入点名字（属性名字或方法截取名字）是不是存在Bean，如果存在，则直接根据注入点名字取获取bean，如果不存在，则会走@Autowired注解的逻辑，会根据注入点类型去找Bean</li></ol> <h4 id="依赖注入的源码流程"><a href="#依赖注入的源码流程" class="header-anchor">#</a> 依赖注入的源码流程</h4> <h5 id="resolvedependency-方法源码解析"><a href="#resolvedependency-方法源码解析" class="header-anchor">#</a> resolveDependency()方法源码解析</h5> <p>依赖注入的核心方法是resolveDependency()</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>@Nullable
Object resolveDependency(DependencyDescriptor descriptor, @Nullable String requestingBeanName,
        @Nullable Set&lt;String&gt; autowiredBeanNames, @Nullable TypeConverter typeConverter) throws BeansException;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>该方法表示，传入一个依赖描述（DependencyDescriptor），该方法会根据该依赖描述从BeanFactory中找出对应的唯一的一个Bean对象，这也是AutowiredAnnotationBeanPostProcessor最终会执行的代码，找出合适的Bean并赋值给@Autowired标注的属性。</strong></p> <p><img src="https://gitee.com/lxk_kaige/blogImage/raw/master/img/Spring%E4%B8%AD%E6%A0%B9%E6%8D%AEType%E6%89%BEBean%E7%9A%84%E6%B5%81%E7%A8%8B.png" alt="Spring中根据Type找Bean的流程"></p> <h5 id="findautowirecandidates-方法源码解析"><a href="#findautowirecandidates-方法源码解析" class="header-anchor">#</a> <strong>findAutowireCandidates()方法源码解析</strong></h5> <ol><li>找出BeanFactory中类型为type的所有的Bean的名字，注意是名字，而不是Bean对象，因为我们可以根据BeanDefinition就能判断和当前type是不是匹配</li> <li>把resolvableDependencies中key为type的对象找出来并添加到result中</li> <li>遍历根据type找出的beanName，判断当前beanName对应的Bean是不是能够被自动注入</li> <li>先判断beanName对应的BeanDefinition中的autowireCandidate属性，如果为false，表示不能用来进行自动注入，如果为true则继续进行判断</li> <li>判断当前type是不是泛型，如果是泛型是会把容器中所有的beanName找出来的，如果是这种情况，那么在这一步中就要获取到泛型的真正类型，然后进行匹配，如果当前beanName和当前泛型对应的真实类型匹配，那么则继续判断</li> <li>如果当前DependencyDescriptor上存在@Qualifier注解，那么则要判断当前beanName上是否定义了Qualifier，并且是否和当前DependencyDescriptor上的Qualifier相等，相等则匹配</li> <li>经过上述验证之后，当前beanName才能成为一个可注入的，添加到result中</li></ol> <p><img src="https://gitee.com/lxk_kaige/blogImage/raw/master/img/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%B5%81%E7%A8%8B.png" alt="依赖注入流程"></p> <p><strong>特殊情况下：</strong></p> <p>自己注入自己</p> <p>会先根据UserService类型去找Bean，找到两个，然后根据属性名字“userService”找到一个beanName为userService的Bean，但是我们直接运行Spring，会发现注入的是“userService1”的那个Bean。</p> <p>这是因为Spring中进行了控制，尽量“<strong>自己不注入自己</strong>”。</p> <p><strong>注入时加了@Qualifier注解时的流程，对应上面的第6步</strong></p> <div class="language- line-numbers-mode"><pre class="language-text"><code>/**
		 * 对找出的候选Bean进行过滤，首先候选Bean不是自己，然后候选Bean是支持自动注入给其他Bean的
		 * isAutowireCandidate为什么需要过滤?
		 *  1. 有可能有的Bean设置了autowired-candiate = false
		 *  2. 父类有一个@AutoWired注入了一个泛型类，将子类交给spring管理时，就需要过滤了，因为根据泛型类会得到工厂中所有的Bean
		 */
		for (String candidate : candidateNames) {
			if (!isSelfReference(beanName, candidate) &amp;&amp; isAutowireCandidate(candidate, descriptor)) {
				addCandidateEntry(result, candidate, descriptor, requiredType);
			}
		}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>核心代码在isAutowireCandidate(candidate, descriptor)中，此方法用来过滤找出的候选Bean，其中判断了autowiredCandidate属性，候选Bean的beanClass属性与当前注入点的type是否匹配，Qualifier属性等。</p> <p><strong>分析源码后得知@Qualifier注解生效分为两种情况：</strong></p> <ol><li>注入点与候选Bean都加了@Qualifier注解，并且value值相同</li> <li>注入点加了@Qualifier注解，并且候选Bean的beanName与注入点@Qualifier注解的value属性相同</li></ol> <p>当在一个单例Bean注入原型Bean时</p> <p>​	同一个单例Bean中的原型Bean其实也是单例的，因为spring只执行了一次依赖注入操作。</p> <p>如果想要单例Bean中注入的原型Bean也是原型的，站在源码的角度去思考，肯定需要执行多次依赖注入操作，在spring中提供了		   ObjectFactory可以让使用者实现此功能，在源码中如果一个Bean中注入了一个ObjectFactory类型的Bean，会有特殊处理，当spring初始化代码走到此处，判断是此类型，会直接返回一个DependencyObjectProvider，每当用户调用DependencyObjectProvider.getObject时，会再走一次依赖注入流程，也就是doResolveDependency（）方法</p> <h4 id="bean初始化的生命周期"><a href="#bean初始化的生命周期" class="header-anchor">#</a> Bean初始化的生命周期</h4> <p>在spring创建一个Bean初始化完成后，允许调用者定义一些初始化完成后需要立即执行的方法。</p> <ol><li><p>@PostConstruct</p></li> <li><p>实现InitializingBean的afterPropertiesSet方法</p></li> <li><p>BeanDefinition配置initMethodName (xml配置bean时，指定init-method属性)</p></li></ol> <p><strong>接下来分析何时调用以及spring是如何发现这些外部定义的方法的</strong></p> <ol><li>第三次后置处理器调用时会将当前正在创建过程中的Bean中有定义@PostConstruct注解的方法缓存到lifecycleMetadataCache中</li> <li>第七次后置处理器执行时，当前Bean依赖注入已经完成，最终通过org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor#postProcessBeforeInitialization后置处理器，通过反射执行缓存在lifecycleMetadataCache中的Bean初始化方法</li> <li>接着会执行org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#invokeInitMethods方法，此方法会先后执行实现了InitializingBean类的afterPropertiesSet方法以及BeanDefinition配置initMethodName (xml配置bean时，指定init-method属性)</li></ol> <h4 id="bean销毁的生命周期"><a href="#bean销毁的生命周期" class="header-anchor">#</a> Bean销毁的生命周期</h4> <p>当spring容器执行close()/registerShutdownHook()方法时，如果容器中的Bean有定义销毁方法时，会执行此销毁方法</p> <ol><li>实现DisposableBean/AutoCloseable</li> <li>BeanDefinition中定义了destroyMethodName（正常情况下）</li> <li>BeanDefinition中定义了destroyMethodName（特殊情况 inferred，目前只发现在@Bean的默认值下destroyMethodName会是此特殊值）并且方法中有定义close/shutdown方法</li> <li>@PreDestroy</li></ol> <p><strong>接下来分析何时调用以及spring是如何发现这些外部定义的方法的</strong></p> <ol><li>首先在第三次后置处理器调用时会将当前正在创建过程中的Bean中有定义@PreDestroy注解的方法缓存到lifecycleMetadataCache中。</li> <li>在每一个Bean初始化完成后，都会执行org.springframework.beans.factory.support.AbstractBeanFactory#registerDisposableBeanIfNecessary方法，此方法会将符合条件的Bean缓存到会被执行销毁方法的缓存（disposableBeans）中。</li> <li>判断是否符合条件，关键的方法在requiresDestruction(bean, mbd)，只有符合上面的4条规则才会被缓存。</li> <li>当调用spring容器的close()/registerShutdownHook()时，会去disposableBeans中遍历并去执行包装类的destroy方法</li></ol> <p><strong>执行顺序总结：</strong></p> <p>当一个Bean对于上面4中方法都满足时，并不会全部执行销毁方法</p> <p>被@PreDestroy修饰的方法一定会执行并且排在第一位 》实现了DisposableBean接口 || （实现了AutoCloseable接口 || 存在第3中情况）</p> <p>并且在（实现了AutoCloseable接口 || 存在第3中情况）情况下，spring会先去匹配close方法，再去匹配shutdown方法</p> <h4 id="spring启动过程源码解析"><a href="#spring启动过程源码解析" class="header-anchor">#</a> Spring启动过程源码解析</h4> <h4 id="aop源码类详解"><a href="#aop源码类详解" class="header-anchor">#</a> AOP源码类详解</h4> <p>自动代理创建器</p> <p>AbstractAutoProxyCreator</p> <div class="language- extra-class"><pre><code>BeanNameAutoProxyCreator
DefaultAdvisorAutoProxyCreator
AnnotationAwareAspectJAutoProxyCreator
</code></pre></div><p>BeanNameAutoProxyCreator:</p> <ol><li>因为实现了BeanPostProcessor,且实现了postProcessAfterInitialization方法，被spring管理的Bean，到最后都会执行此方法</li> <li>根据外部手动调用setBeanNames()来确定那些Bean需要被进行aop代理</li> <li>得到根据外部手动调用的setInterceptorNames()传入的代理逻辑</li> <li>使用ProxyFactory来创建代理对象</li></ol> <p>DefaultAdvisorAutoProxyCreator</p> <ol><li>因为实现了BeanPostProcessor,且实现了postProcessAfterInitialization方法，被spring管理的Bean，到最后都会执行此方法</li> <li>拿到spring容器中所有的实现了Advisor的类</li> <li>循环拿到的Advisor集合，判断当前初始化的Bean是否需要被代理（根据Advisor的具体实现类来判断ClassFilter，Method）</li> <li>使用ProxyFactory来创建代理对象</li></ol> <p>AnnotationAwareAspectJAutoProxyCreator</p> <ol><li>因为实现了BeanPostProcessor,且实现了postProcessAfterInitialization方法，被spring管理的Bean，到最后都会执行此方法</li> <li>拿到spring容器中所有的实现了Advisor的类 + AspectJ的代理逻辑</li> <li>循环拿到的Advisor集合，判断当前初始化的Bean是否需要被代理（根据Advisor的具体实现类来判断ClassFilter，Method）</li> <li>使用ProxyFactory来创建代理对象</li></ol> <h4 id="循环引用"><a href="#循环引用" class="header-anchor">#</a> 循环引用</h4> <p><img src="https://gitee.com/lxk_kaige/blogImage/raw/master/img/1.png" alt="1592539097062-7912a20c-f209-47bd-bdc0-d6d4485ab395"></p> <p><strong>singletonObjects</strong>：（<strong>一级缓存</strong>）缓存某个beanName对应的经过了完整生命周期的bean</p> <p><strong>earlySingletonObjects</strong>：（<strong>二级缓存</strong>）缓存提前通过原始对象进行了AOP之后得到的代理对象，原始对象还没有进行属性注入和后续的BeanPostProcessor等生命周期</p> <p><strong>singletonFactories</strong>：（<strong>三级缓存</strong>）缓存的是一个ObjectFactory，也就是一个Lambda表达式。在创建一个Bean时，在每个Bean的生成过程中，都会提前暴露一个Lambda表达式，并保存到三级缓存中，这个Lambda表达式<strong>可能用到，也可能用不到</strong>，如果没有出现循环依赖依赖本bean，那么这个Lambda表达式无用，本bean按照自己的生命周期执行，执行完后直接把本bean放入singletonObjects中即可，如果出现了循环依赖依赖了本bean，则从三级缓存中获取Lambda表达式，并执行Lambda表达式得到一个AOP之后的代理对象(如果有AOP的话，如果无需AOP，则直接得到一个原始对象)，并把得到的对象放入二级缓存</p> <p>其实还要一个缓存，就是<strong>earlyProxyReferences</strong>，它用来记录某个原始对象是否进行过AOP了。</p> <h3 id="_3-springmvc相关"><a href="#_3-springmvc相关" class="header-anchor">#</a> 3. springMvc相关</h3> <h4 id="_3-1-pringframework实现无xml配置mvc项目"><a href="#_3-1-pringframework实现无xml配置mvc项目" class="header-anchor">#</a> 3.1 pringFramework实现无XML配置mvc项目</h4> <p>springFramework  2.5   以后，官方文档已经推荐我们使用注解的方式去配置mvc项目，不用像以前一样配置繁琐的xml ( applicationContext.xml，applicationMvc.xml ....) 以及web.xml。</p> <p><strong>由于springmvc是基于servlet Api构建的，在servlet 3.0 以前，让servlet容器加载项目，只有一个入口，那就是web.xml，只有项目中有此web.xml，servlet容器（例如：tomcat） 才能以此为入口，进一步初始化项目。</strong></p> <p><strong>而在servlet 3.0 以后：</strong></p> <ol><li>只要项目指定目录META-IF/services目录下有以javax.servlet.ServletContainerInitializer命名的文件，并在文件中写入实现了ServletContainerInitializer接口的类的全路径名，那么servlet容器就可以检测到。而springFramework 2.5 后的版本中正是巧妙的运用了此方法，在spring-web项目中，就有此文件。</li></ol> <p><img src="C:%5CUsers%5CLXK%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1582728498915.png" alt="1582728498915"></p> <ol start="2"><li>前面说过，servlet 3.0 提供了另一个入口，在servlet容器检测到实现了ServletContainerInitializer接口的类后，就会执行此类的onStartup()方法进行项目初始化。spring用@HandlesTypes( ) 配合使用，在执行onStartup()方法时，检测实现了@HandlesTypes标记的类，并把此类作为参数放入onStartup()方法的第一个参数，而后循环进行onStartup()方法。</li></ol> <p><img src="C:%5CUsers%5CLXK%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1582729173330.png" alt="1582729173330"></p> <p><img src="C:%5CUsers%5CLXK%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1582729206152.png" alt="1582729206152"></p> <p>那么spring  2.5  以后的版本中，spring具体是如何实现零xml配置，基于注解就可以方便得配置项目呢?</p> <p>在spring  2.5  以前，各个配置文件都配置了那些内容呢？</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>&lt;web-app&gt;
	// 配置ContextLoaderListener监听器,加载spring配置文件并初始化spring环境
    &lt;listener&gt;
        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
    &lt;/listener&gt;

    &lt;context-param&gt;
        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
        &lt;param-value&gt;/WEB-INF/app-context.xml&lt;/param-value&gt;
    &lt;/context-param&gt;
	//配置DispatcherServlet，并加载springmvc配置文件
    &lt;servlet&gt;
        &lt;servlet-name&gt;app&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
            &lt;param-value&gt;classpath:springmvc-config.xml&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;/servlet&gt;

    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;app&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/app/*&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;

&lt;/web-app&gt;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br></div></div><p>由上面代码可以看到，在一个简单的mvc项目中，web.xml主要是用来配置ContextLoaderListener监听器用来初始化spring环境，注册DispatcherServlet这个servlet。也就是当作一个servlet容器的入口处，用来初始化项目。</p> <p><strong>代替web.xml</strong></p> <img src="C:\Users\LXK\AppData\Roaming\Typora\typora-user-images\1582729403390.png" alt="1582729403390" style="zoom:200%;"> <div class="language- line-numbers-mode"><pre class="language-text"><code>WebEnvironmentInitializer实现了WebApplicationInitializer接口，spring中实现了ServletContainerInitializer接口的类为SpringServletContainerInitializer，此类上的注解@HandlesTypes标记的正是WebApplicationInitializer.class。

所以在tomcat容器执行SpringServletContainerInitializer的onStartup()方法时，会检测@HandlesTypes标记的WebApplicationInitializer接口的实现了，并放入onStartup()中循环执行它的onStartup()。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>代替application-context.xml , application-mvc.xml</strong></p> <div class="language- line-numbers-mode"><pre class="language-text"><code>application-context.xml 

此类xml中最主要的就是扫描Bean,此项工作可以交给@ComponentScan()完成，@ComponentScan()会扫描指定的包中的类，并根据条件注册进spring容器中。
其他皆是配置Bean的配置，可以用@Bean完成。

application-mvc.xml
可以使用@Bean的方式配置mvc的一些东西，例如：消息转换器，视图解析器。。。
也可以在配置类中加上@EnableWebMvc并实现WebMvcConfigurer接口来配置。

如果实现了WebMvcConfigurer接口，则必须加@EnableWebMvc注解，此时0xml配置类的onStartup方法中初始化spring上下文的Context就不能调用refresh方法了

如果继承了WebMvcConfigurationSupport类，则可以不加@EnableWebMvc注解，此时0xml配置类的onStartup方法中初始化spring上下文的Context就不能调用refresh方法了


</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h4 id="_3-2-内嵌tomcat"><a href="#_3-2-内嵌tomcat" class="header-anchor">#</a> 3.2 内嵌tomcat</h4> <p>基于上面的无XML配置的mvc项目，可以使用内嵌tomcat来启动项目</p> <p><img src="C:%5CUsers%5CLXK%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1593682786926.png" alt="1593682786926"></p> <p>springMvc对于静态资源的匹配，采用的客户端缓存，当一个客户端第二次请求同一个静态资源时，判断此资源是否更改过，如果没有，则直接返回客户端HTTP状态码 304 ，客户端收到此状态码会去浏览器缓存中去找此静态资源</p> <h3 id="_3-3-springmvc源码解析"><a href="#_3-3-springmvc源码解析" class="header-anchor">#</a> 3.3 springMvc源码解析</h3> <ul><li><h4 id="springmvc初始化controller的流程"><a href="#springmvc初始化controller的流程" class="header-anchor">#</a> springMvc初始化Controller的流程</h4></li> <li><p>DispatcherServlet的类图</p></li></ul> <p><img src="C:%5CUsers%5CLXK%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1594026941590.png" alt="1594026941590"></p> <ol><li><p>org.springframework.web.servlet.HttpServletBean#init</p></li> <li><p>org.springframework.web.servlet.FrameworkServlet#initServletBean</p></li> <li><p>org.springframework.web.servlet.FrameworkServlet#initWebApplicationContext</p></li> <li><p>org.springframework.web.servlet.FrameworkServlet#configureAndRefreshWebApplicationContext</p></li> <li><p>org.springframework.context.support.AbstractApplicationContext#refresh(初始化spring环境)</p></li> <li><p>org.springframework.context.support.AbstractApplicationContext#finishRefresh(代码走到这里spring环境已经初始化完毕，开始最后发布事件，由对应的监听处理事件也就是开始执行springmvc的相关初始化)</p></li> <li><p>org.springframework.context.support.AbstractApplicationContext#publishEvent(org.springframework.context.ApplicationEvent)</p></li> <li><p>。。。。</p></li> <li><p>org.springframework.web.servlet.FrameworkServlet.ContextRefreshListener#onApplicationEvent</p></li> <li><p>org.springframework.web.servlet.FrameworkServlet#onApplicationEvent</p></li> <li><p>org.springframework.web.servlet.DispatcherServlet#initStrategies</p></li> <li><p>org.springframework.web.servlet.DispatcherServlet#initHandlerMappings</p></li> <li><p>org.springframework.web.servlet.handler.AbstractHandlerMethodMapping#afterPropertiesSet</p></li> <li><p>org.springframework.web.servlet.handler.AbstractHandlerMethodMapping#initHandlerMethods</p></li></ol> <div class="language- line-numbers-mode"><pre class="language-text"><code>springmvc的初始化在spring环境初始化完成后，通过发布事件的方式由指定的监听来执行
FrameworkServlet.this.onApplicationEvent(event);

DispatcherServlet实际上就是一个servlet,servlet有三个应用最普遍的方init(),doGet(),doPost()。
而SpringMvc就是在DispatcherServlet实例化完成后，由servlet容器调用init()方法进行环境的初始化的，其中就包括对controller的解析

环境初始化走到org.springframework.web.servlet.DispatcherServlet#initHandlerMappings方法时，会去解析spring-webmvc项目的DispatcherServlet.properties文件，去实例化默认的两个HandlerMapping（BeanNameUrlHandlerMapping,RequestMappingHandlerMapping）因为RequestMappingHandlerMapping的父类实现了InitializingBean接口，当他走完Bean的生命周期后，会调用afterPropertiesSet()方法,继而调用initHandlerMethods()方法去加载controller并放入MappingRegistry.urlLookup和MappingRegistry.mappingLookup
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><ul><li><h4 id="springmvc根据请求找controller的流程"><a href="#springmvc根据请求找controller的流程" class="header-anchor">#</a> SpringMvc根据请求找Controller的流程</h4> <ol><li>org.springframework.web.servlet.FrameworkServlet#doGet org.springframework.web.servlet.FrameworkServlet#doPost</li> <li>org.springframework.web.servlet.FrameworkServlet#processRequest</li> <li>org.springframework.web.servlet.DispatcherServlet#doService</li> <li>org.springframework.web.servlet.DispatcherServlet#doDispatch</li> <li>org.springframework.web.servlet.DispatcherServlet#getHandler</li> <li>org.springframework.web.servlet.handler.AbstractHandlerMethodMapping#getHandlerInternal或org.springframework.web.servlet.handler.AbstractUrlHandlerMapping#getHandlerInternal</li> <li>org.springframework.web.servlet.handler.AbstractHandlerMethodMapping#lookupHandlerMethod</li> <li>org.springframework.web.servlet.handler.AbstractHandlerMethodMapping.MappingRegistry#urlLookup或org.springframework.web.servlet.handler.AbstractHandlerMethodMapping.MappingRegistry#mappingLookup</li></ol> <div class="language- line-numbers-mode"><pre class="language-text"><code>核心代码在DispatcherServlet的doDispatch()方法，此方法作用：
1. 首先确定处理请求的controller的方法(附带拦截此方法的拦截器)
2. 得到对应的handlerAdapter
3. 方法执行前，执行拦截器
4. 对应请求的方法参数赋值
5. 调用目标方法
6. 调用视图解析器或消息转换器
7. 方法执行后，执行拦截器
8. 方法返回后，执行拦截器

此处只分析如何匹配请求对应的方法
在org.springframework.web.servlet.DispatcherServlet#getHandler方法中，根据提供的handlerMappings循环遍历去匹配路径。

handlerMappings默认情况下，有两个(通过解析DispatcherServlet.properties文件)类，RequestMappingHandlerMapping与BeanNameUrlHandlerMapping对应上面的第六步，而获取对应的handlerAdapter也是根据这个来的，对应doDispatch()的第二步

RequestMappingHandlerMapping用来处理通过@Controller的方式成为controller的类
BeanNameUrlHandlerMapping用来处理通过实现Controller或HttpRequestHandler接口的方式程为controller的类

最后走到lookupHandlerMethod()方法，根据request中的uri和urlLookup或mappingLookup去匹配


</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div></li> <li><h4 id="springmvc方法参数赋值"><a href="#springmvc方法参数赋值" class="header-anchor">#</a> SpringMvc方法参数赋值</h4> <ol><li><p>org.springframework.web.servlet.DispatcherServlet#doDispatch</p></li> <li><p>org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter#handle</p></li> <li><p>org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter#handleInternal</p></li> <li><p>org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter#invokeHandlerMethod</p></li> <li><p>org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod#invokeAndHandle</p></li> <li><p>org.springframework.web.method.support.InvocableHandlerMethod#invokeForRequest</p></li> <li><p>org.springframework.web.method.support.InvocableHandlerMethod#getMethodArgumentValues</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>默认提供三种HandlerAdapter来进行方法参数赋值以及调用
org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter,\
org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter,\
org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter
分别对应三种不同方式成为controller的类

此处只分析RequestMappingHandlerAdapter(最常用)
方法参数赋值的逻辑就在org.springframework.web.method.support.InvocableHandlerMethod#getMethodArgumentValues中
首先根据参数的属性找到符合条件的HandlerMethodArgumentResolver，然后将参数替换，此处有一个缓存，用来缓存已经解析过的方法参数以及参数对应的HandlerMethodArgumentResolver,因为寻找HandlerMethodArgumentResolver的操作还是挺费时间的，正常状态下有多达26个HandlerMethodArgumentResolver
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div></li></ol></li> <li><h4 id="springmvc如何返回数据的"><a href="#springmvc如何返回数据的" class="header-anchor">#</a> SpringMvc如何返回数据的</h4></li></ul> <ol><li><p>org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter#handle</p></li> <li><p>org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter#handleInternal</p></li> <li><p>org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter#invokeHandlerMethod</p></li> <li><p>org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod#invokeAndHandle</p></li> <li><p>org.springframework.web.method.support.HandlerMethodReturnValueHandlerComposite#handleReturnValue</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>返回数据在执行方法之后
在第5步，handleReturnValue中
//寻找合适的返回参数解析器 例如：方法上加了@ResponseBody 就会用RequestResponseBodyMethodProcessor
HandlerMethodReturnValueHandler handler = selectHandler(returnValue, returnType);

// 例如：方法上加了@ResponseBody就会把返回参数格式化为json并响应
handler.handleReturnValue(returnValue, returnType, mavContainer, webRequest);

如果方法返回是一个视图，那么会返回到最外层的DisPatcherServlet处理，首先会匹配合适的视图解析器，然后经过一系列的流程(是转发还是重定向。。)最终转发或重定向视图
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div></li></ol> <ul><li><h4 id="springboot如何扩展springmvc-实现响应静态资源"><a href="#springboot如何扩展springmvc-实现响应静态资源" class="header-anchor">#</a> SpringBoot如何扩展SpringMvc，实现响应静态资源</h4></li></ul> <p>SimpleUrlHandlerMapping</p> <h3 id="_3-4-springmvc扩展点"><a href="#_3-4-springmvc扩展点" class="header-anchor">#</a> 3.4 springMvc扩展点</h3> <ul><li><h4 id="handlermapping"><a href="#handlermapping" class="header-anchor">#</a> HandlerMapping</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>HandlerMapping用来匹配请求对应的处理方法，springboot就是扩展了HandlerMapping实现web程序下可以响应resources目录下的静态资源文件(springmvc只能相应webapp下的静态资源)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li> <li><h4 id="handlermethodargumentresolver"><a href="#handlermethodargumentresolver" class="header-anchor">#</a> HandlerMethodArgumentResolver</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>请求对应的处理方法的参数赋值，可以自定义。
例如：项目中某些方法需要获取用户信息，在方法参数中直接赋值的方式，就可以使用实现HandlerMethodArgumentResolver来实现。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></li> <li><h4 id="handlermethodreturnvaluehandler"><a href="#handlermethodreturnvaluehandler" class="header-anchor">#</a> HandlerMethodReturnValueHandler</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>请求对应的处理方法执行完毕，返回时的解析器,可以当作扩展点使用
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li> <li><h4 id="viewresolver"><a href="#viewresolver" class="header-anchor">#</a> ViewResolver</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>视图解析器
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h4 id="converter"><a href="#converter" class="header-anchor">#</a> Converter</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>类型转换器，例如映射方法形参为Date类型，前端发过来是json字符串，将字符串转换为Date的参数解析
String---&gt;Date，mvc有默认的Converter转换器，但是形参出必须加@DateTimeFormat注解，并且指定patten的格式化，而且格式必须与入参格式一致

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div></li></ul> <h3 id="_10-spring与mvc杂项"><a href="#_10-spring与mvc杂项" class="header-anchor">#</a> 10. spring与mvc杂项</h3> <h4 id="_10-1父子容器问题"><a href="#_10-1父子容器问题" class="header-anchor">#</a> 10.1父子容器问题</h4> <p>​	有spring的容器为父容器，springmvc为子容器。</p> <p>​	子容器可以获取父容器的bean对象，父容器不可获取子容器的bean对象</p> <p>​	注意：这里仅是bean，对于一些属性文件@Value(&quot;${server.name}&quot;) 子容器也是获取不到的</p> <h3 id="_3-springboot"><a href="#_3-springboot" class="header-anchor">#</a> 3. springBoot</h3> <h4 id="_1-1-springboot-自动配置原理"><a href="#_1-1-springboot-自动配置原理" class="header-anchor">#</a> 1.1 springBoot 自动配置原理</h4> <p>springBoot默认会去解析项目<strong>resources/META-INF/spring.factories</strong>配置文件，并会加载配置文件中的类注入到spring容器中去。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>springboot的启动类中添加的@SpringBootApplication注解完成了这一功能，他是一个组合注解，真正完成这一功能的是@EnableAutoConfiguration注解，此注解使用@Import导入了一个AutoConfigurationImportSelector类，此类实现了ImportSelector接口，在spring初始化环境，扫描到有@Import注解后，将@Import中的类注册成为一个BeanDefinition并且，如果此类实现了ImportSelector接口，那么直接执行ImportSelector接口的selectImports方法，AutoConfigurationImportSelector类的selectImports方法会去解析spring.factories配置文件，并将配置文件中的类，注册到spring环境中。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>自动配置mvc：WebMvcAutoConfiguration</p> <p>自动配置DisPatcherServlet：DispatcherServletAutoConfiguration</p> <h4 id="_1-2-springboot-监听器"><a href="#_1-2-springboot-监听器" class="header-anchor">#</a> 1.2 springBoot 监听器</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>举例说明：
事件：小明和小红打了一架
事件源：
事件对象：打架的过程
事件驱动器：管理事件

事件驱动器
SimpleApplicationEventMulticaster

在spring容器启动调用refresh()时，
initApplicationEventMulticaster()方法会去初始化事件驱动器。
registerListeners()方法会去初始化实现了ApplicationListener接口的监听类
finishBeanFactoryInitialization(beanFactory);方法不仅会调用spring的后置处理器，当所有的bean初始化完成后，还会初始化所有的以注解形式实现的监听类

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h4 id="_1-3-内置web容器"><a href="#_1-3-内置web容器" class="header-anchor">#</a> 1.3 内置web容器</h4> <p><strong>配置web容器</strong>：</p> <ol><li>yml配置</li> <li>TomcatServletWebServerFactory</li></ol> <div class="language- line-numbers-mode"><pre class="language-text"><code>/**
     * 配置web容器第一种方式
     * @return
     */
    @Bean
    public TomcatServletWebServerFactory tomcatServletWebServerFactory() {
        TomcatServletWebServerFactory tomcatServletWebServerFactory = new TomcatServletWebServerFactory();
        tomcatServletWebServerFactory.setPort(8081);
        return tomcatServletWebServerFactory;
    }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><ol start="3"><li>WebServerFactoryCustomizer</li></ol> <div class="language- line-numbers-mode"><pre class="language-text"><code> /**
     * 配置web容器第二种方式
     * 优先级：WebServerFactoryCustomizer &gt; yml &gt; TomcatServletWebServerFactory
     * @return
     */
    @Bean
    public WebServerFactoryCustomizer webServerFactoryCustomizer() {
        //factory 为当前正在使用的web容器的Factory
        WebServerFactoryCustomizer webServerFactoryCustomizer = factory -&gt; {
            TomcatServletWebServerFactory factory1 = (TomcatServletWebServerFactory) factory;
            factory1.setPort(8088);
        };
        return webServerFactoryCustomizer;
    }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>对于以上配置，只能配置springBoot已经确定使用哪个web容器了，配置此web容器的一些配置，并不能够切换web容器。</p> <p><strong>切换web容器</strong></p> <p>springBoot自动配置web容器的类是ServletWebServerFactoryAutoConfiguration类（在<strong>spring-boot-autoconfigure包下的resources/META-INF/spring.factories</strong>）</p> <p>默认情况下springboot配置的web容器为tomcat，在源码中可以看到</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>ServletWebServerFactoryAutoConfiguration类的@Import({ServletWebServerFactoryAutoConfiguration.BeanPostProcessorsRegistrar.class, EmbeddedTomcat.class, EmbeddedJetty.class, EmbeddedUndertow.class})
导入的类中，包含三种web容器分别为:Tomcat,Jetty,Undertow。
在这三个EmbeddedTomcat，EmbeddedJetty，EmbeddedUndertow类中，都有
@ConditionalOnMissingBean(
        value = {ServletWebServerFactory.class},
        search = SearchStrategy.CURRENT
    )
    注解，表示如果spring容器中存在某个接口或实现类，那么就不会将加了此注解的类放入spring容器中，又因为EmbeddedTomcat排在第一个，当解析完EmbeddedTomcat类后，spring容器中存在了一个TomcatServletWebServerFactory，此类实现了ServletWebServerFactory接口，所以后面的两个web容器就不会注入到spring环境中了。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>如果想要切换默认的web容器，需要在springboot的包中，剔除tomcat的包，在引入其他web容器的包即可。</p> <p>注意：</p> <ol><li><p>springboot项目如果使用jar包的方式，那么springboot会屏蔽掉servlet 3.0的规范，也就是说实现WebApplicationInitializer接口，servlet容器并不会调用onStartup()方法，但是如果使用war包的情况下，默认是没有屏蔽的。</p> <p>jar包方式，如果想要实现相同的功能，springboot提供了另外一个接口ServletContextInitializer</p></li> <li><p>如果项目中有类继承了WebMvcConfigurationSupport类，会导致springBoot自动配置mvc失效，因为WebMvcAutoConfiguration自动配置类中有一个注解@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)</p></li></ol> <h4 id="_1-4-启动源码分析"><a href="#_1-4-启动源码分析" class="header-anchor">#</a> 1.4 启动源码分析</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>构造方法：
ApplicationContextInitializer
ApplicationListener
run方法：
SpringApplicationRunListener
ApplicationRunner，CommandLineRunner
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p><img src="https://gitee.com/lxk_kaige/blogImage/raw/master/img/image-20200831143553749.png" alt="image-20200831143553749"></p> <h4 id="_1-5-默认拦截静态资源"><a href="#_1-5-默认拦截静态资源" class="header-anchor">#</a> 1.5 默认拦截静态资源</h4> <p>springMvc中接收外部请求的唯一入口最终都会执行DisPatcherServlet的doDispatch方法</p> <p>在doDispatch方法中org.springframework.web.servlet.DispatcherServlet#getHandler是一个重点，他来确定具体要哪个方法处理外部的请求以及拦截此请求的拦截器</p> <p><img src="https://gitee.com/lxk_kaige/blogImage/raw/master/img/image-20200914173843128.png" alt="image-20200914173630960"></p> <p><img src="https://gitee.com/lxk_kaige/blogImage/raw/master/img/image-20200914173843128.png" alt="image-20200914174256705"></p> <p><img src="https://gitee.com/lxk_kaige/blogImage/raw/master/img/image-20200914173843128.png" alt="image-20200914173843128"></p> <div class="language- line-numbers-mode"><pre class="language-text"><code>AbstractHandlerMethodMapping 处理外部请求对应的处理方法(controller下的方法)
AbstractUrlHandlerMapping 处理静态资源

HandlerExecutionChain
ResourceHttpRequestHandler
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>最后执行到org.springframework.web.servlet.HandlerAdapter#handle方法，是最终执行请求对应方法/寻找请求对应资源的方法，寻找请求对应的资源org.springframework.web.servlet.resource.ResourceHttpRequestHandler#handleRequest的getResource()方法中</p> <p><img src="https://gitee.com/lxk_kaige/blogImage/raw/master/img/image-20200915090146901.png" alt="image-20200915090146901"></p> <p>根据org.springframework.boot.autoconfigure.web.ResourceProperties#CLASSPATH_RESOURCE_LOCATIONS中默认的几种去找对应的资源，找到后返回</p> <ol><li>classpath:/META-INF/resources/</li> <li>classpath:/resources/</li> <li>classpath:/static/</li> <li>classpath:/public/</li> <li>webapp下的resources、static、public</li></ol> <p>由此可见，如果我们要扩展静态资源的映射可以从ResourceProperties的staticLocations[]入手</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>@SpringBootApplication
public class AppApplication implements WebMvcConfigurer, InitializingBean {
	@Autowired
	ResourceProperties resourceProperties;

	/**
	 * 第二种方式：通过实现WebMvcConfigurer接口，重写其中的addResourceHandlers方法
	 * 可以指定指定的请求去找指定的资源路径
	 *
	 * @param registry
	 */
	@Override
	public void addResourceHandlers(ResourceHandlerRegistry registry) {
		registry.addResourceHandler(&quot;/aa/**&quot;)
				.addResourceLocations(&quot;classpath:/aa/&quot;);
	}

	public static void main(String[] args) {
		SpringApplication.run(AppApplication.class);
	}

	/**
	 * 第一种方式：直接扩展staticLocations数组，在数组中添加新的路径，但是这种只支持/**所有外部请求，不能指定想要拦截的路径
	 *
	 * @throws Exception
	 */
	@Override
	public void afterPropertiesSet() throws Exception {
		String[] staticLocations = resourceProperties.getStaticLocations();
		List&lt;String&gt; list = new ArrayList&lt;&gt;();
		list.addAll(Arrays.asList(staticLocations));
		list.add(&quot;classpath:/aa/&quot;);
		String[] str = new String[list.size()];
		resourceProperties.setStaticLocations(list.toArray(str));
	}
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br></div></div><h6 id="遇到的问题"><a href="#遇到的问题" class="header-anchor">#</a> <strong>遇到的问题</strong></h6> <p><strong>为什么存放在webapp/resources/此文件夹下的静态文件，访问时可以直接通过classpath:/resources/找到相应静态文件？</strong></p> <p>idea在编译后，会将webapp/resources/转换为classpath（target\classes）下面的resources文件夹里面</p> <h3 id="_4-spring-源码编译"><a href="#_4-spring-源码编译" class="header-anchor">#</a> 4. spring 源码编译</h3> <h5 id="问题"><a href="#问题" class="header-anchor">#</a> 问题：</h5> <p>找不到org.springframework.aop.target</p> <p>因为我在Idea的设置中，将名称为target的目录给隐藏了</p> <p>requestMappingHandlerMapping -&gt; {ConfigurationClassBeanDefinitionReader$ConfigurationClassBeanDefinition@3381} &quot;Root bean: class [null]; scope=; abstract=false; lazyInit=false; autowireMode=3; dependencyCheck=0; autowireCandidate=true; primary=false; factoryBeanName=org.springframework.web.servlet.config.annotation.DelegatingWebMvcConfiguration; factoryMethodName=requestMappingHandlerMapping; initMethodName=null; destroyMethodName=(inferred); defined in org.springframework.web.servlet.config.annotation.DelegatingWebMvcConfiguration&quot;</p> <p>docker start oracle11g</p></div></div>  <div class="page-edit"><div class="edit-link"><a href="https://github.com/xugaoyi/vuepress-theme-vdoing/edit/master/docs/03.技术/01.技术文档/16.Spring源码分析.md" target="_blank" rel="noopener noreferrer">编辑</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">2022/05/20, 14:06:32</span></div></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><a href="/vuepress-theme-vdoing/pages/4e8444e2d534d14f/" class="page-nav-centre page-nav-centre-prev"><div class="tooltip">yaml语言教程</div></a> <a href="/vuepress-theme-vdoing/pages/4c778760be26d8b3/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">GitHub高级搜索技巧</div></a></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/vuepress-theme-vdoing/pages/4e8444e2d534d14f/" class="prev">yaml语言教程</a></span> <span class="next"><a href="/vuepress-theme-vdoing/pages/4c778760be26d8b3/">GitHub高级搜索技巧</a>→
      </span></p></div></div></div> <div class="article-list"><div class="article-title"><a href="/vuepress-theme-vdoing/archives/" class="iconfont icon-bi">最近更新</a></div> <div class="article-wrapper"><dl><dd>01</dd> <dt><a href="/vuepress-theme-vdoing/pages/829589/"><div>
            我做了一个手写春联小网页，祝大家虎年暴富
            <span class="title-tag">
              原创
            </span></div></a> <span class="date">01-28</span></dt></dl><dl><dd>02</dd> <dt><a href="/vuepress-theme-vdoing/pages/dcebaf/"><div>
            一行代码“黑”掉任意网站
            <span class="title-tag">
              原创
            </span></div></a> <span class="date">11-25</span></dt></dl><dl><dd>03</dd> <dt><a href="/vuepress-theme-vdoing/pages/a61298/"><div>
            33个非常实用的JavaScript一行代码
            <!----></div></a> <span class="date">11-02</span></dt></dl> <dl><dd></dd> <dt><a href="/vuepress-theme-vdoing/archives/" class="more">更多文章&gt;</a></dt></dl></div></div></main></div> <div class="footer"><div class="icons"><a href="mailto:894072666@qq.com" title="发邮件" target="_blank" class="iconfont icon-youjian"></a><a href="https://github.com/xugaoyi" title="GitHub" target="_blank" class="iconfont icon-github"></a><a href="https://music.163.com/#/playlist?id=755597173" title="听音乐" target="_blank" class="iconfont icon-erji"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2019-2022
    <span>Evan Xu | <a href="https://github.com/xugaoyi/vuepress-theme-vdoing/blob/master/LICENSE" target="_blank">MIT License</a></span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"><div></div></div></div>
    <script src="/vuepress-theme-vdoing/assets/js/app.524f9bbc.js" defer></script><script src="/vuepress-theme-vdoing/assets/js/3.421046c6.js" defer></script><script src="/vuepress-theme-vdoing/assets/js/57.40a59478.js" defer></script>
  </body>
</html>
