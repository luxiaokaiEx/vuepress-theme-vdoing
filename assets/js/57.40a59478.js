(window.webpackJsonp=window.webpackJsonp||[]).push([[57],{684:function(e,a,s){"use strict";s.r(a);var t=s(40),n=Object(t.a)({},(function(){var e=this,a=e.$createElement,s=e._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"spring源码分析"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#spring源码分析"}},[e._v("#")]),e._v(" Spring源码分析")]),e._v(" "),s("h3",{attrs:{id:"_1-spring应用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-spring应用"}},[e._v("#")]),e._v(" 1 .spring应用")]),e._v(" "),s("h4",{attrs:{id:"_1-1-spring声明bean的方式有哪些"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-spring声明bean的方式有哪些"}},[e._v("#")]),e._v(" 1.1 spring声明Bean的方式有哪些？")]),e._v(" "),s("p",[e._v("声明式：")]),e._v(" "),s("p",[e._v("xml")]),e._v(" "),s("p",[e._v("@Bean，@Component")]),e._v(" "),s("p",[e._v("编程式")]),e._v(" "),s("p",[e._v("applicationContext.registerBean();")]),e._v(" "),s("h4",{attrs:{id:"_1-2-spring的注入方式有哪些"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-spring的注入方式有哪些"}},[e._v("#")]),e._v(" 1.2 spring的注入方式有哪些？")]),e._v(" "),s("p",[e._v("构造方法注入")]),e._v(" "),s("p",[e._v("setter方法注入")]),e._v(" "),s("h4",{attrs:{id:"_1-3-spring的注入模型有哪些"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-spring的注入模型有哪些"}},[e._v("#")]),e._v(" 1.3 spring的注入模型有哪些？")]),e._v(" "),s("p",[e._v("no：不注入")]),e._v(" "),s("p",[e._v("byType：通过类型")]),e._v(" "),s("p",[e._v("byName：通过名字")]),e._v(" "),s("p",[e._v("constructor ：通过构造函数")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("构造方法注入的方式,只能通过constructor注入模型去注入\n\nsetter注入的方式,可以通过byType,byName这两种注入模型去注入\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br")])]),s("p",[e._v("spring的自动装配（自动注入）")]),e._v(" "),s("p",[e._v("其实spring的自动装配（自动注入）是针对xml配置的情况下说的")]),e._v(" "),s("p",[e._v("解释：定义一个bean，里面又依赖某个bean,在没有对这个依赖bean做任何注入的时候，如果对这个定义bean，指定某种自动装配。那么Spring会根据自动装配模型，通过setter方法或构造函数，进行属性填充。")]),e._v(" "),s("p",[e._v("例如：byName")]),e._v(" "),s("p",[s("img",{attrs:{src:"https://img-blog.csdnimg.cn/2019120221060660.png",alt:"img"}})]),e._v(" "),s("p",[e._v("例如：byType")]),e._v(" "),s("p",[s("img",{attrs:{src:"https://img-blog.csdnimg.cn/20191202210643558.png",alt:"img"}})]),e._v(" "),s("p",[e._v("需要在定义的bean中，定义相应的setter方法")]),e._v(" "),s("h4",{attrs:{id:"_1-4-autowired与自动装配"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-4-autowired与自动装配"}},[e._v("#")]),e._v(" 1.4 @Autowired与自动装配")]),e._v(" "),s("p",[e._v("@Autowired先通过类型去匹配，再根据名字去匹配。")]),e._v(" "),s("p",[s("strong",[e._v("这里可以思考一下，为什么先通过类型去匹配，再根据名字去匹配？")])]),e._v(" "),s("p",[e._v("因为在spring的单例池中beanName是作为key的，也就是唯一的，如果直接根据byName去找有可能找到的Bean并不是你预想的那个Bean（例如想@Autowired orderService，但是可能UserService这个类在注入spring时，使用的beanName是orderService），所以必须要现根据要注入的属性的Type去找，找到一个直接注入，找到多个再根据byName去注入")]),e._v(" "),s("p",[e._v("在实际开发中，我们没有指定bean的自动装配模型，大多数都是在需要依赖属性上面加上@Autowired注解。无需多余代码，Spring也会把这个依赖属性完成填充。那是不是说明加了@Autowired注解就说明我们这个bean就是自动装配了呢。其实不然，通过源码，可以看到，@Autowired注解是调用了bean的后置处理器AutowiredAnnotationBeanPostProcessor的postProcessProperties方法完成属性注入。方法的核心其实就是运用java反射技术，field.set(object,args);")]),e._v(" "),s("p",[s("img",{attrs:{src:"https://img-blog.csdnimg.cn/20191202204858568.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0x1b1FpYW5nUWlhbmcyMDE3,size_16,color_FFFFFF,t_70",alt:"img"}})]),e._v(" "),s("p",[e._v("这个跟bean注入模型不对应，bean的注入模型分为byType,和byName,constructor。基于setter方法和构造函数，而在spring源码中对于@Autowired注解是通过java反射的技术完成的。")]),e._v(" "),s("h4",{attrs:{id:"_1-5-autowired与-resource"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-5-autowired与-resource"}},[e._v("#")]),e._v(" 1.5 @Autowired与@Resource")]),e._v(" "),s("p",[e._v("两者的包不同，@Resource是 javax.annotation包下的，归属于jdk;@Autowire是 org.springframework.beans.factory.annotation包下的，归属于Spring。\n两者完成属性注入时使用的bean的后置处理器不同。@Resource 是用CommonAnnotationBeanPostProcessor.postProcessProperties()方法，@Autowire则是AutowiredAnnotationBeanPostProcessor bean后置处理器来完成属性注入。")]),e._v(" "),s("p",[e._v("一般在开发中不建议使用@Resource，@Resource注入时是直接使用byName模型的，有可能会与预期注入的bean不一样。")]),e._v(" "),s("h4",{attrs:{id:"_1-6-如何将一个对象放入spring容器中"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-6-如何将一个对象放入spring容器中"}},[e._v("#")]),e._v(" 1.6 如何将一个对象放入spring容器中")]),e._v(" "),s("p",[e._v("注意：是对象交给spring管理而不是类交给spring管理")]),e._v(" "),s("ol",[s("li",[s("p",[e._v("@Bean")])]),e._v(" "),s("li",[s("p",[e._v("FactoryBean")])]),e._v(" "),s("li",[s("p",[e._v("getBeanFactory().registerSingleton()")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("其中第三种方法，只是将对象交给spring处理，但是此对象的依赖spring并不会管理，需要手动管理\n\n因为此对象是自己手动new出来的，无论在spring容器初始化完成后，还是初始化完成前他都不会经过springBean的生命周期\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br")])])])]),e._v(" "),s("h4",{attrs:{id:"_1-7-bean的初始化与销毁"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-7-bean的初始化与销毁"}},[e._v("#")]),e._v(" 1.7 Bean的初始化与销毁")]),e._v(" "),s("p",[e._v("如何在Bean初始化完成后，立即执行一些操作？")]),e._v(" "),s("ol",[s("li",[s("p",[e._v("@PostConstruct")])]),e._v(" "),s("li",[s("p",[e._v("实现InitializingBean的afterPropertiesSet方法")])]),e._v(" "),s("li",[s("p",[e._v("xml配置bean时，指定init-method属性")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("这三种方法是有先后顺序的\n如果这三种全部都配置了，那么执行顺序是：1---\x3e2---\x3e3\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br")])])])]),e._v(" "),s("p",[e._v("销毁：")]),e._v(" "),s("ol",[s("li",[e._v("DisposableBean/AutoCloseable")]),e._v(" "),s("li",[e._v("BeanDefinition中定义了destroyMethodName")]),e._v(" "),s("li",[e._v("@PreDestroy")]),e._v(" "),s("li",[e._v("如果是@Bean方式注入spring，类中存在close或者shutdown方法")])]),e._v(" "),s("h4",{attrs:{id:"_1-8-spring容器初始化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-8-spring容器初始化"}},[e._v("#")]),e._v(" 1.8 spring容器初始化")]),e._v(" "),s("p",[e._v("如何在spring容器启动后，停止前做一些自定义的操作？")]),e._v(" "),s("ol",[s("li",[s("p",[e._v("实现 SmartLifecycle接口")])]),e._v(" "),s("li",[s("p",[e._v("实现Lifecycle接口")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("SmartLifecycle接口是继承了Lifecycle接口的，所以一般情况下用第一种方式\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br")])])])]),e._v(" "),s("h4",{attrs:{id:"_1-9-代理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-9-代理"}},[e._v("#")]),e._v(" 1.9 代理")]),e._v(" "),s("h5",{attrs:{id:"静态代理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#静态代理"}},[e._v("#")]),e._v(" 静态代理")]),e._v(" "),s("p",[e._v("静态代理比较简单，有.java，.class文件，是可以看到的。")]),e._v(" "),s("p",[e._v("Api类")]),e._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("package")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token namespace"}},[e._v("com"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("kai"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("proxy"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("statics")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("public")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("interface")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Api")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n\n\t"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("public")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("void")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("sayHi")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br")])]),s("p",[e._v("Target类")]),e._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("package")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token namespace"}},[e._v("com"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("kai"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("proxy"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("statics")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("public")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("class")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Target")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("implements")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Api")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n\n\t"),s("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[e._v("@Override")]),e._v("\n\t"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("public")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("void")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("sayHi")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n\t\t"),s("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("System")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("out"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("println")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Target")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("class")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("getSimpleName")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("+")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('" sayHi。。。"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br")])]),s("p",[e._v("Proxy类")]),e._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("package")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token namespace"}},[e._v("com"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("kai"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("proxy"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("statics")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("public")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("class")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Proxy")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("implements")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Api")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n\t"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("private")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Target")]),e._v(" target"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\n\t"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("public")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Proxy")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Target")]),e._v(" target"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n\t\t"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("target "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" target"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n\n\t"),s("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[e._v("@Override")]),e._v("\n\t"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("public")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("void")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("sayHi")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n\t\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("//执行代理对象逻辑")]),e._v("\n\t\t"),s("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("System")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("out"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("println")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"Proxy begin。。。"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\t\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("//执行目标对象的方法")]),e._v("\n\t\ttarget"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("sayHi")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\t\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("//执行代理对象逻辑")]),e._v("\n\t\t"),s("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("System")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("out"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("println")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"Proxy end。。。"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br"),s("span",{staticClass:"line-number"},[e._v("15")]),s("br"),s("span",{staticClass:"line-number"},[e._v("16")]),s("br"),s("span",{staticClass:"line-number"},[e._v("17")]),s("br"),s("span",{staticClass:"line-number"},[e._v("18")]),s("br"),s("span",{staticClass:"line-number"},[e._v("19")]),s("br"),s("span",{staticClass:"line-number"},[e._v("20")]),s("br")])]),s("p",[e._v("Main类")]),e._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("package")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token namespace"}},[e._v("com"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("kai"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("proxy"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("statics")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("public")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("class")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Main")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n\t"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("public")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("static")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("void")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("main")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("String")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v(" args"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n\t\t"),s("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Target")]),e._v(" target "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("new")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Target")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\t\t"),s("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Proxy")]),e._v(" proxy "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("new")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Proxy")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("target"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\t\tproxy"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("sayHi")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br")])]),s("h5",{attrs:{id:"动态代理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#动态代理"}},[e._v("#")]),e._v(" 动态代理")]),e._v(" "),s("ol",[s("li",[e._v("jdk动态代理")]),e._v(" "),s("li",[e._v("cglib动态代理")])]),e._v(" "),s("p",[e._v("动态代理的代理对象没有.java，.class文件，直接就是生成的字节码对象并被ClassLoader加载到jvm内存中")]),e._v(" "),s("ol",[s("li",[e._v("Spring 5.x 中 AOP 默认依旧使用 JDK 动态代理。")]),e._v(" "),s("li",[e._v("SpringBoot 2.x 开始，为了解决使用 JDK 动态代理可能导致的类型转化异常而默认使用 CGLIB。")]),e._v(" "),s("li",[e._v("在 SpringBoot 2.x 中，如果需要默认使用 JDK 动态代理可以通过配置项"),s("code",[e._v("spring.aop.proxy-target-class=false")]),e._v("来进行修改，"),s("code",[e._v("proxyTargetClass")]),e._v("配置已无效")])]),e._v(" "),s("h4",{attrs:{id:"_1-10-aop"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-10-aop"}},[e._v("#")]),e._v(" 1.10 AOP")]),e._v(" "),s("ol",[s("li",[e._v("Aspect")])]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("Aspect：切面\n用官方文档的话来说就是一个横切关注点模块化，切面就和spring的容器一样，是多个组件组合在一起就叫做切面。\n可以简单地认为, 使用 @Aspect 注解的类就是切面\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br")])]),s("ol",[s("li",[e._v("Join point")])]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("Join point：连接点\n程序执行期间切点的一个点，如方法执行或异常处理期间的一个点。（具体哪个方法才会执行Advice）\n简单来说，连接点就是被拦截到的程序执行点，因为Spring只支持方法类型的连接点，所以在Spring中连接点就是被拦截到的方法。\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br")])]),s("ol",[s("li",[e._v("Advice")])]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("Advice：通知，代理逻辑\n代理逻辑是指拦截到连接点之后要执行的代码\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br")])]),s("ol",[s("li",[e._v("Pointcut")])]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v(" Pointcut：切点\n 切点是对连接点进行拦截的条件定义，是连接点的集合\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br")])]),s("ol",[s("li",[e._v("advisor")])]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("advisor = advice + PointCut\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br")])]),s("ol",[s("li",[e._v("Introduction")])]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br")])]),s("ol",[s("li",[e._v("Target object")])]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("Target object：目标对象\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br")])]),s("ol",[s("li",[e._v("AOP proxy")])]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v(" AOP proxy：代理对象\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br")])]),s("ol",[s("li",[e._v("Weaving")])]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("Weaving：织入\n织入是将切面和业务逻辑对象连接起来, 并创建通知代理的过程。织入可以在编译时，类加载时和运行时完成。在编译时进行织入就是静态代理，而在运行时进行织入则是动态代理。\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br")])]),s("h3",{attrs:{id:"_2-spring源码解析"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-spring源码解析"}},[e._v("#")]),e._v(" 2.spring源码解析")]),e._v(" "),s("h4",{attrs:{id:"_2-1-1-beandeinintion-bean定义"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-1-beandeinintion-bean定义"}},[e._v("#")]),e._v(" 2.1.1 BeanDeinintion（Bean定义）")]),e._v(" "),s("p",[e._v("spring中对于类中是否加入了类似@Comment，@Lazy。。。的注解，使用的是AMS字节码技术判断的")]),e._v(" "),s("p",[s("strong",[e._v("为什么spring中需要将Bean包装为BeanDefinition？")])]),e._v(" "),s("p",[e._v("在spring中对于一个Bean的解析只会做一次，需要将Bean的一些属性进行缓存，例如是否为单例，是否为懒加载，beanClass，beanName。。。。，想要将属性进行缓存，必然需要一个类对Bean进行包装，BeanDefinition就是做这个工作的")]),e._v(" "),s("p",[s("strong",[e._v("试想一下，如果没有BeanDefinition，会出现什么现象？")])]),e._v(" "),s("p",[e._v("首先，因为Bean属性没有缓存，在加载Bean的时候，解析了一次类的属性，在走Bean声明周期，生成Bean对象的时候又解析一次类的属性，getBean时，还需要解析一次。。。。。。")]),e._v(" "),s("h4",{attrs:{id:"_2-1-2-beandefinitionreader"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-2-beandefinitionreader"}},[e._v("#")]),e._v(" 2.1.2 BeanDefinitionReader")]),e._v(" "),s("p",[e._v("负责读取BeanDefinition的接口，传入单个的类，将类读取，解析成为一个BeanDefinition。传入的类不必要加@Comonent，但是一些Bean属性（lazy，scope。。。）的注解还是需要加的")]),e._v(" "),s("h4",{attrs:{id:"_2-1-3-beandefinitionregisty"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-3-beandefinitionregisty"}},[e._v("#")]),e._v(" 2.1.3 BeanDefinitionRegisty")]),e._v(" "),s("p",[e._v("负责注册，存放BeanDefinition的接口")]),e._v(" "),s("h4",{attrs:{id:"_2-1-4-classpathbeandefinitionscanner"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-4-classpathbeandefinitionscanner"}},[e._v("#")]),e._v(" 2.1.4 ClassPathBeanDefinitionScanner")]),e._v(" "),s("p",[e._v("负责扫描给定包下面加了@Commonent，@Service。。。但是不包括@Bean的类，并封装成为BeanDefinition")]),e._v(" "),s("h4",{attrs:{id:"_2-1-5-metadatareader"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-5-metadatareader"}},[e._v("#")]),e._v(" 2.1.5 MetadataReader")]),e._v(" "),s("p",[e._v("负责读取Class的元数据以及被注解的元数据，并封装为Metadata并作为BeanDefinition的一个属性")]),e._v(" "),s("h4",{attrs:{id:"_2-1-6-annotationawareordercomparator"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-6-annotationawareordercomparator"}},[e._v("#")]),e._v(" 2.1.6 AnnotationAwareOrderComparator")]),e._v(" "),s("p",[e._v("spring提供的比较器，主要用来对List集合中的元素针对（@Order注解的值，@Priority的值，Ordered接口）进行排序，可以单独使用，不必在spring环境中")]),e._v(" "),s("h4",{attrs:{id:"_2-1-7-beanfactory"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-7-beanfactory"}},[e._v("#")]),e._v(" 2.1.7 BeanFactory")]),e._v(" "),s("p",[e._v("Bean工厂接口，负责生成Bean，获取Bean")]),e._v(" "),s("p",[e._v("有许多实现类，各个实现类负责一部分Bean工厂的功能")]),e._v(" "),s("p",[e._v("比较核心的实现类为DefaultListableBeanFactory")]),e._v(" "),s("p",[e._v("上面这些使用下面的图来联系起来看比较容易理解")]),e._v(" "),s("p",[s("img",{attrs:{src:"https://gitee.com/lxk_kaige/blogImage/raw/master/img/image-20201012090823502.png",alt:"image-20201012090823502"}})]),e._v(" "),s("p",[e._v("BeanFactory：顶级接口，提供了获取bean，是否存在bean，是否为单例bean等方法")]),e._v(" "),s("p",[e._v("ListableBeanFactory：派生接口，提供了一些关于BeanDefinition的方法以及其他方式获取Bean，例如是否包含bd，获取bd的数量，获取所有bd的名字，以及根据类型获取Bean。。。")]),e._v(" "),s("p",[e._v("HierarchicalBeanFactory：派生接口，提供获取父Bean工厂的方法")]),e._v(" "),s("p",[e._v("。。。")]),e._v(" "),s("p",[e._v("根据每个接口的名字，就可以大概看出每个接口负责的功能")]),e._v(" "),s("p",[e._v("可以看到DefaultListableBeanFactory实现的各个顶级接口有BeanFactory，BeanDefinitionRegistry，说明DefaultListableBeanFactory拥有BeanDefinition的存放以及注册，生成Bean，获取Bean等关于Bean的操作的功能")]),e._v(" "),s("h4",{attrs:{id:"factorybean"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#factorybean"}},[e._v("#")]),e._v(" FactoryBean")]),e._v(" "),s("blockquote",[s("p",[s("strong",[e._v("FactoryBean工厂本身会存在单例池中，而getObject()返回的对象会存在factoryBeanObjectCache中")])])]),e._v(" "),s("p",[e._v("FactoryBean为一个生产Bean的工厂类，他在spring中是一个特殊的Bean，会生成两个Bean，一个getObject()返回的对象，一个FactoryBean本身")]),e._v(" "),s("p",[e._v("当使用@Autowired注入FactoryBean的beanName时，spring会注入getObject()返回的Bean")]),e._v(" "),s("p",[e._v("当使用@Autowired注入实现FactoryBean传入的泛型类时（public class MyFactoryBean implements FactoryBean ），@Autowired 开始的byType会将当前实现了FactoryBean的Bean也加入候选，最终根据byName决定最终使用哪个。")]),e._v(" "),s("p",[e._v("如果想注入factoryBean本身，需要加上&")]),e._v(" "),s("p",[e._v("FactoryBean，实际上是懒加载，但是有一个实现类SmartFactoryBean，可以变为非懒加载，启动时创建此Bean")]),e._v(" "),s("h4",{attrs:{id:"aware"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#aware"}},[e._v("#")]),e._v(" Aware")]),e._v(" "),s("p",[e._v("spring提供的回调接口，有多个实现类，例如BeanNameAware，BeanFactoryAware。。。")]),e._v(" "),s("p",[e._v("当一个Bean初始化已经完成后，如果实现了Aware接口，就会回调此接口的方法")]),e._v(" "),s("h4",{attrs:{id:"解析配置类以及扫描源码解析"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#解析配置类以及扫描源码解析"}},[e._v("#")]),e._v(" 解析配置类以及扫描源码解析")]),e._v(" "),s("p",[e._v("首先分析一下spring中BeanDefinitionRegistryPostProcessor以及BeanFactoryPostProcessor两个类的执行过程")]),e._v(" "),s("p",[e._v("BeanDefinitionRegistryPostProcessor为BeanFactoryPostProcessor的子类")]),e._v(" "),s("h4",{attrs:{id:"执行beanfactorypostprocessor"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#执行beanfactorypostprocessor"}},[e._v("#")]),e._v(" 执行BeanFactoryPostProcessor")]),e._v(" "),s("ol",[s("li",[e._v("执行通过ApplicationContext添加进来的BeanDefinitionRegistryPostProcessor的postProcessBeanDefinitionRegistry()方法")]),e._v(" "),s("li",[e._v("执行BeanFactory中实现了PriorityOrdered接口的BeanDefinitionRegistryPostProcessor的postProcessBeanDefinitionRegistry()方法")]),e._v(" "),s("li",[e._v("执行BeanFactory中实现了Ordered接口的BeanDefinitionRegistryPostProcessor的postProcessBeanDefinitionRegistry()方法")]),e._v(" "),s("li",[e._v("执行BeanFactory中其他的BeanDefinitionRegistryPostProcessor的postProcessBeanDefinitionRegistry()方法")]),e._v(" "),s("li",[e._v("执行上面所有的BeanDefinitionRegistryPostProcessor的postProcessBeanFactory()方法")]),e._v(" "),s("li",[e._v("执行通过ApplicationContext添加进来的BeanFactoryPostProcessor的postProcessBeanFactory()方法")]),e._v(" "),s("li",[e._v("执行BeanFactory中实现了PriorityOrdered接口的BeanFactoryPostProcessor的postProcessBeanFactory()方法")]),e._v(" "),s("li",[e._v("执行BeanFactory中实现了Ordered接口的BeanFactoryPostProcessor的postProcessBeanFactory()方法")]),e._v(" "),s("li",[e._v("执行BeanFactory中其他的BeanFactoryPostProcessor的postProcessBeanFactory()方法")])]),e._v(" "),s("h4",{attrs:{id:"解析配置类"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#解析配置类"}},[e._v("#")]),e._v(" 解析配置类")]),e._v(" "),s("p",[e._v("spring中配置类的解析与扫描是org.springframework.context.annotation.ConfigurationClassPostProcessor#postProcessBeanDefinitionRegistry来完成的，执行时机就在第2步中，主要的功能为（筛选配置类，处理扫描ComponentScan，处理import，处理@Bean。。。）并注册成为BeanDefinition")]),e._v(" "),s("p",[s("img",{attrs:{src:"https://gitee.com/lxk_kaige/blogImage/raw/master/img/Spring%E9%85%8D%E7%BD%AE%E7%B1%BB%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B.png",alt:"Spring配置类解析流程.png"}})]),e._v(" "),s("ol",[s("li",[s("p",[e._v("在启动Spring时，需要传入一个AppConfig.class给ApplicationContext，ApplicationContext会根据AppConfig类封装为一个BeanDefinition，这种BeanDefinition我们把它称为配置类BeanDefinition。")])]),e._v(" "),s("li",[s("p",[e._v("ConfigurationClassPostProcessor中会把配置类BeanDefinition取出来")])]),e._v(" "),s("li",[s("p",[e._v("构造一个ConfigurationClassParser用来解析配置类BeanDefinition，并且会生成一个配置类对象ConfigurationClass")])]),e._v(" "),s("li",[s("p",[e._v("如果配置类上存在@Component注解，那么"),s("strong",[e._v("解析配置类中的内部类（这里有递归，如果内部类也是配置类的话）")])])]),e._v(" "),s("li",[s("p",[e._v("如果配置类上存在@PropertySource注解，那么则解析该注解，并得到PropertySource对象，并添加到environment中去")])]),e._v(" "),s("li",[s("p",[e._v("如果配置类上存在@ComponentScan注解，那么则解析该注解，进行扫描，扫描得到一系列的BeanDefinition对象，然后判断这些BeanDefinition是不是也是配置类BeanDefinition（只要存在@Component注解就是配置类，所以基本上扫描出来的都是配置类），如果是则继续解析该配置类，"),s("strong",[e._v("（也有递归）")]),e._v("，并且会生成对应的ConfigurationClass")])]),e._v(" "),s("li",[s("p",[e._v("如果配置类上存在@Import注解，那么则判断Import的类的类型：")])]),e._v(" "),s("li",[s("ol",[s("li",[e._v("如果是ImportSelector，那么调用执行selectImports方法得到类名，然后在把这个类当做配置类进行解析**（也是递归）**")])])]),e._v(" "),s("li",[s("p",[e._v("如果是ImportBeanDefinitionRegistrar，那么则生成一个ImportBeanDefinitionRegistrar实例对象，并添加到配置类对象中（ConfigurationClass）的"),s("strong",[e._v("importBeanDefinitionRegistrars")]),e._v("属性中。")])]),e._v(" "),s("li",[s("p",[e._v("如果配置类上存在@ImportResource注解，那么则把导入进来的资源路径存在配置类对象中的"),s("strong",[e._v("importedResources")]),e._v("属性中。")])]),e._v(" "),s("li",[s("p",[e._v("如果配置类中存在@Bean的方法，那么则把这些方法封装为BeanMethod对象，并添加到配置类对象中的"),s("strong",[e._v("beanMethods")]),e._v("属性中。")])]),e._v(" "),s("li",[s("p",[e._v("如果配置类实现了某些接口，则看这些接口内是否定义了@Bean的默认方法")])]),e._v(" "),s("li",[s("p",[e._v("如果配置类有父类，则把父类当做配置类进行解析")])]),e._v(" "),s("li",[s("p",[e._v("AppConfig这个配置类会对应一个ConfigurationClass，同时在解析的过程中也会生成另外的一些ConfigurationClass，接下来就利用reader来进一步解析ConfigurationClass")])]),e._v(" "),s("li",[s("ol",[s("li",[e._v("如果ConfigurationClass是通过@Import注解导入进来的，则把这个类生成一个BeanDefinition，同时解析这个类上@Scope,@Lazy等注解信息，并注册BeanDefinition")])])]),e._v(" "),s("li",[s("p",[e._v("如果ConfigurationClass中存在一些BeanMethod，也就是定义了一些@Bean，那么则解析这些@Bean，并生成对应的BeanDefinition，并注册")])]),e._v(" "),s("li",[s("p",[e._v("如果ConfigurationClass中导入了一些资源文件，比如xx.xml，那么则解析这些xx.xml文件，得到并注册BeanDefinition")])]),e._v(" "),s("li",[s("p",[e._v("如果ConfigurationClass中导入了一些ImportBeanDefinitionRegistrar，那么则执行对应的registerBeanDefinitions进行BeanDefinition的注册")])])]),e._v(" "),s("h3",{attrs:{id:"总结一下"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#总结一下"}},[e._v("#")]),e._v(" 总结一下")]),e._v(" "),s("ol",[s("li",[e._v("解析AppConfig类，生成对应的ConfigurationClass")]),e._v(" "),s("li",[e._v("再扫描，扫描到的类都会生成对应的BeanDefinition，并且同时这些类也是ConfigurationClass")]),e._v(" "),s("li",[e._v("再解析ConfigurationClass的其他信息，比如@ImportResource注解的处理，@Import注解的处理，@Bean注解的处理")])]),e._v(" "),s("h4",{attrs:{id:"合并beandefinition"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#合并beandefinition"}},[e._v("#")]),e._v(" 合并BeanDefinition")]),e._v(" "),s("p",[e._v("在开始拿所有的BeanDefinition，并去循环getBean()时，会去合并，合并完成后，bd变为RootDeanDefinition，RootDeanDefinition不支持设置parent")]),e._v(" "),s("p",[e._v("beanName ----\x3e 合并后的bdMap ------\x3e 没有 -------\x3e BeanDefinitionMap -----\x3e  有父db ------\x3e子/父generalBeanDefinition --------\x3e 合并为RootBeanDefinition")]),e._v(" "),s("p",[s("strong",[e._v("FactoryBean的生命周期详图")])]),e._v(" "),s("p",[e._v("https://www.processon.com/view/link/5f8d340d5653bb06ef073b0e")]),e._v(" "),s("p",[e._v('被@Scope("request")注解修饰的类，形成的Bean存在request.getAtrribute();中')]),e._v(" "),s("p",[e._v("第一次执行BeanPostProcess时，可以通过实现对应的BeanPostProcess来打断spring接下来的创建Bean流程，说白了如果第一次调用BeanPostProcess返回不为空，就不会执行spring自带的创建Bean的流程了（例如：推断构造方法，实例化对象，依赖注入。。。）")]),e._v(" "),s("p",[e._v("![Bean的生命周期流程 (2)](https://gitee.com/lxk_kaige/blogImage/raw/master/img/Bean的生命周期流程 (2).png)")]),e._v(" "),s("h4",{attrs:{id:"autowired注入源码流程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#autowired注入源码流程"}},[e._v("#")]),e._v(" @AutoWired注入源码流程")]),e._v(" "),s("p",[e._v("@AutoWired和@Resource这些对于一个Bean完成属性填充的操作，入口方法都是org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#populateBean")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("/**\n  * 完成属性填充，自动注入\n  * \t第五次和第六次后置处理器的调用\n  * \tInstantiationAwareBeanPostProcessor postProcessAfterInstantiation\n  * \tInstantiationAwareBeanPostProcessor postProcessProperties\n  *\n  */\n populateBean(beanName, mbd, instanceWrapper);\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br")])]),s("p",[s("strong",[e._v("@AutoWired属性注入的大致流程：")])]),e._v(" "),s("ol",[s("li",[s("p",[e._v("首先，会走第五次后置处理器的调用，执行Bean实例化后的操作InstantiationAwareBeanPostProcessor postProcessAfterInstantiation")])]),e._v(" "),s("li",[s("p",[e._v("然后判断当前Bean的注入模型是什么byName or byType，一般来说如果没有特殊操作的话，@Autowired注入的Bean的注入模型都是No。")])]),e._v(" "),s("li",[s("p",[e._v("如果为No，开始执行第六次后置处理器的调用，执行InstantiationAwareBeanPostProcessor的postProcessProperties")])]),e._v(" "),s("li",[s("p",[e._v("@Autowired对应的核心InstantiationAwareBeanPostProcessor是org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor#postProcessProperties")])]),e._v(" "),s("li",[s("p",[e._v("在AutowiredAnnotationBeanPostProcessor的postProcessProperties真正开始执行属性注入的操作")])]),e._v(" "),s("li",[s("p",[e._v("首先去拿当前Bean的注入点，当前Bean的注入点（@Autowired，@Resource，@Value...）在第三次后置处理器调用时已经解析过，此处直接从缓存获取")])]),e._v(" "),s("li",[s("p",[e._v("遍历每个能够注入的属性，进行注入，注入依赖 element可能是Method,也可能是Field")])]),e._v(" "),s("li",[s("p",[e._v("处理Field的为：org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.AutowiredFieldElement#inject")])]),e._v(" "),s("li",[s("p",[e._v("处理Method的为：org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.AutowiredMethodElement#inject")])]),e._v(" "),s("li",[s("p",[e._v("然后开始真正处理依赖，resolveDependency（），会在后面依赖注入的源码流程着重分析。")])])]),e._v(" "),s("h4",{attrs:{id:"resource注入源码流程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#resource注入源码流程"}},[e._v("#")]),e._v(" @Resource注入源码流程")]),e._v(" "),s("p",[e._v("@Resource属性注入的过程与@AutoWired的流程有重叠的地方，真正开始处理的地方都在第六次后置处理器的执行，只不过处理@AutoWired的BeanPostProcess是AutowiredAnnotationBeanPostProcessor，而处理@Resource的BeanPostProcess是CommonAnnotationBeanPostProcessor。")]),e._v(" "),s("p",[e._v("接下来分析CommonAnnotationBeanPostProcessor的postProcessProperties方法")]),e._v(" "),s("ol",[s("li",[e._v("首先去拿当前Bean的注入点（只拿@Resource），当前Bean的注入点（@Autowired，@Resource，@Value...）在第三次后置处理器调用时已经解析过，此处直接从缓存获取")]),e._v(" "),s("li",[e._v("遍历每个能够注入的属性，进行注入，注入依赖 element可能是Method,也可能是Field")]),e._v(" "),s("li",[e._v("处理@Rsource注入点是字段或方法的都在org.springframework.beans.factory.annotation.InjectionMetadata.InjectedElement#inject中")]),e._v(" "),s("li",[e._v("具体的逻辑在org.springframework.context.annotation.CommonAnnotationBeanPostProcessor#autowireResource中")]),e._v(" "),s("li",[e._v("如果使用@Resource注入一个Bean，并且根据name属性/属性名/方法名得到的beanName不存在当前beanFactory中的话，代码就会走@AutoWired的依赖注入的逻辑，先byType，再byName")]),e._v(" "),s("li",[e._v("正常情况下，根据@Resource的name属性/属性名/set方法参数得到的要注入的beanName存在beanFactory中的话，直接去根据beanName得到一个bean")])]),e._v(" "),s("p",[s("strong",[e._v("总结：")])]),e._v(" "),s("p",[e._v("对于@Resource：")]),e._v(" "),s("ol",[s("li",[e._v("如果@Resource注解中指定了name属性，那么则只会根据name属性的值去找bean，如果找不到则报错")]),e._v(" "),s("li",[e._v("如果@Resource注解没有指定name属性，那么会先判断当前注入点名字（属性名字或方法截取名字）是不是存在Bean，如果存在，则直接根据注入点名字取获取bean，如果不存在，则会走@Autowired注解的逻辑，会根据注入点类型去找Bean")])]),e._v(" "),s("h4",{attrs:{id:"依赖注入的源码流程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#依赖注入的源码流程"}},[e._v("#")]),e._v(" 依赖注入的源码流程")]),e._v(" "),s("h5",{attrs:{id:"resolvedependency-方法源码解析"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#resolvedependency-方法源码解析"}},[e._v("#")]),e._v(" resolveDependency()方法源码解析")]),e._v(" "),s("p",[e._v("依赖注入的核心方法是resolveDependency()")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("@Nullable\nObject resolveDependency(DependencyDescriptor descriptor, @Nullable String requestingBeanName,\n        @Nullable Set<String> autowiredBeanNames, @Nullable TypeConverter typeConverter) throws BeansException;\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br")])]),s("p",[s("strong",[e._v("该方法表示，传入一个依赖描述（DependencyDescriptor），该方法会根据该依赖描述从BeanFactory中找出对应的唯一的一个Bean对象，这也是AutowiredAnnotationBeanPostProcessor最终会执行的代码，找出合适的Bean并赋值给@Autowired标注的属性。")])]),e._v(" "),s("p",[s("img",{attrs:{src:"https://gitee.com/lxk_kaige/blogImage/raw/master/img/Spring%E4%B8%AD%E6%A0%B9%E6%8D%AEType%E6%89%BEBean%E7%9A%84%E6%B5%81%E7%A8%8B.png",alt:"Spring中根据Type找Bean的流程"}})]),e._v(" "),s("h5",{attrs:{id:"findautowirecandidates-方法源码解析"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#findautowirecandidates-方法源码解析"}},[e._v("#")]),e._v(" "),s("strong",[e._v("findAutowireCandidates()方法源码解析")])]),e._v(" "),s("ol",[s("li",[e._v("找出BeanFactory中类型为type的所有的Bean的名字，注意是名字，而不是Bean对象，因为我们可以根据BeanDefinition就能判断和当前type是不是匹配")]),e._v(" "),s("li",[e._v("把resolvableDependencies中key为type的对象找出来并添加到result中")]),e._v(" "),s("li",[e._v("遍历根据type找出的beanName，判断当前beanName对应的Bean是不是能够被自动注入")]),e._v(" "),s("li",[e._v("先判断beanName对应的BeanDefinition中的autowireCandidate属性，如果为false，表示不能用来进行自动注入，如果为true则继续进行判断")]),e._v(" "),s("li",[e._v("判断当前type是不是泛型，如果是泛型是会把容器中所有的beanName找出来的，如果是这种情况，那么在这一步中就要获取到泛型的真正类型，然后进行匹配，如果当前beanName和当前泛型对应的真实类型匹配，那么则继续判断")]),e._v(" "),s("li",[e._v("如果当前DependencyDescriptor上存在@Qualifier注解，那么则要判断当前beanName上是否定义了Qualifier，并且是否和当前DependencyDescriptor上的Qualifier相等，相等则匹配")]),e._v(" "),s("li",[e._v("经过上述验证之后，当前beanName才能成为一个可注入的，添加到result中")])]),e._v(" "),s("p",[s("img",{attrs:{src:"https://gitee.com/lxk_kaige/blogImage/raw/master/img/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%B5%81%E7%A8%8B.png",alt:"依赖注入流程"}})]),e._v(" "),s("p",[s("strong",[e._v("特殊情况下：")])]),e._v(" "),s("p",[e._v("自己注入自己")]),e._v(" "),s("p",[e._v("会先根据UserService类型去找Bean，找到两个，然后根据属性名字“userService”找到一个beanName为userService的Bean，但是我们直接运行Spring，会发现注入的是“userService1”的那个Bean。")]),e._v(" "),s("p",[e._v("这是因为Spring中进行了控制，尽量“"),s("strong",[e._v("自己不注入自己")]),e._v("”。")]),e._v(" "),s("p",[s("strong",[e._v("注入时加了@Qualifier注解时的流程，对应上面的第6步")])]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("/**\n\t\t * 对找出的候选Bean进行过滤，首先候选Bean不是自己，然后候选Bean是支持自动注入给其他Bean的\n\t\t * isAutowireCandidate为什么需要过滤?\n\t\t *  1. 有可能有的Bean设置了autowired-candiate = false\n\t\t *  2. 父类有一个@AutoWired注入了一个泛型类，将子类交给spring管理时，就需要过滤了，因为根据泛型类会得到工厂中所有的Bean\n\t\t */\n\t\tfor (String candidate : candidateNames) {\n\t\t\tif (!isSelfReference(beanName, candidate) && isAutowireCandidate(candidate, descriptor)) {\n\t\t\t\taddCandidateEntry(result, candidate, descriptor, requiredType);\n\t\t\t}\n\t\t}\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br")])]),s("p",[e._v("核心代码在isAutowireCandidate(candidate, descriptor)中，此方法用来过滤找出的候选Bean，其中判断了autowiredCandidate属性，候选Bean的beanClass属性与当前注入点的type是否匹配，Qualifier属性等。")]),e._v(" "),s("p",[s("strong",[e._v("分析源码后得知@Qualifier注解生效分为两种情况：")])]),e._v(" "),s("ol",[s("li",[e._v("注入点与候选Bean都加了@Qualifier注解，并且value值相同")]),e._v(" "),s("li",[e._v("注入点加了@Qualifier注解，并且候选Bean的beanName与注入点@Qualifier注解的value属性相同")])]),e._v(" "),s("p",[e._v("当在一个单例Bean注入原型Bean时")]),e._v(" "),s("p",[e._v("​\t同一个单例Bean中的原型Bean其实也是单例的，因为spring只执行了一次依赖注入操作。")]),e._v(" "),s("p",[e._v("如果想要单例Bean中注入的原型Bean也是原型的，站在源码的角度去思考，肯定需要执行多次依赖注入操作，在spring中提供了\t\t   ObjectFactory可以让使用者实现此功能，在源码中如果一个Bean中注入了一个ObjectFactory类型的Bean，会有特殊处理，当spring初始化代码走到此处，判断是此类型，会直接返回一个DependencyObjectProvider，每当用户调用DependencyObjectProvider.getObject时，会再走一次依赖注入流程，也就是doResolveDependency（）方法")]),e._v(" "),s("h4",{attrs:{id:"bean初始化的生命周期"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#bean初始化的生命周期"}},[e._v("#")]),e._v(" Bean初始化的生命周期")]),e._v(" "),s("p",[e._v("在spring创建一个Bean初始化完成后，允许调用者定义一些初始化完成后需要立即执行的方法。")]),e._v(" "),s("ol",[s("li",[s("p",[e._v("@PostConstruct")])]),e._v(" "),s("li",[s("p",[e._v("实现InitializingBean的afterPropertiesSet方法")])]),e._v(" "),s("li",[s("p",[e._v("BeanDefinition配置initMethodName (xml配置bean时，指定init-method属性)")])])]),e._v(" "),s("p",[s("strong",[e._v("接下来分析何时调用以及spring是如何发现这些外部定义的方法的")])]),e._v(" "),s("ol",[s("li",[e._v("第三次后置处理器调用时会将当前正在创建过程中的Bean中有定义@PostConstruct注解的方法缓存到lifecycleMetadataCache中")]),e._v(" "),s("li",[e._v("第七次后置处理器执行时，当前Bean依赖注入已经完成，最终通过org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor#postProcessBeforeInitialization后置处理器，通过反射执行缓存在lifecycleMetadataCache中的Bean初始化方法")]),e._v(" "),s("li",[e._v("接着会执行org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#invokeInitMethods方法，此方法会先后执行实现了InitializingBean类的afterPropertiesSet方法以及BeanDefinition配置initMethodName (xml配置bean时，指定init-method属性)")])]),e._v(" "),s("h4",{attrs:{id:"bean销毁的生命周期"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#bean销毁的生命周期"}},[e._v("#")]),e._v(" Bean销毁的生命周期")]),e._v(" "),s("p",[e._v("当spring容器执行close()/registerShutdownHook()方法时，如果容器中的Bean有定义销毁方法时，会执行此销毁方法")]),e._v(" "),s("ol",[s("li",[e._v("实现DisposableBean/AutoCloseable")]),e._v(" "),s("li",[e._v("BeanDefinition中定义了destroyMethodName（正常情况下）")]),e._v(" "),s("li",[e._v("BeanDefinition中定义了destroyMethodName（特殊情况 inferred，目前只发现在@Bean的默认值下destroyMethodName会是此特殊值）并且方法中有定义close/shutdown方法")]),e._v(" "),s("li",[e._v("@PreDestroy")])]),e._v(" "),s("p",[s("strong",[e._v("接下来分析何时调用以及spring是如何发现这些外部定义的方法的")])]),e._v(" "),s("ol",[s("li",[e._v("首先在第三次后置处理器调用时会将当前正在创建过程中的Bean中有定义@PreDestroy注解的方法缓存到lifecycleMetadataCache中。")]),e._v(" "),s("li",[e._v("在每一个Bean初始化完成后，都会执行org.springframework.beans.factory.support.AbstractBeanFactory#registerDisposableBeanIfNecessary方法，此方法会将符合条件的Bean缓存到会被执行销毁方法的缓存（disposableBeans）中。")]),e._v(" "),s("li",[e._v("判断是否符合条件，关键的方法在requiresDestruction(bean, mbd)，只有符合上面的4条规则才会被缓存。")]),e._v(" "),s("li",[e._v("当调用spring容器的close()/registerShutdownHook()时，会去disposableBeans中遍历并去执行包装类的destroy方法")])]),e._v(" "),s("p",[s("strong",[e._v("执行顺序总结：")])]),e._v(" "),s("p",[e._v("当一个Bean对于上面4中方法都满足时，并不会全部执行销毁方法")]),e._v(" "),s("p",[e._v("被@PreDestroy修饰的方法一定会执行并且排在第一位 》实现了DisposableBean接口 || （实现了AutoCloseable接口 || 存在第3中情况）")]),e._v(" "),s("p",[e._v("并且在（实现了AutoCloseable接口 || 存在第3中情况）情况下，spring会先去匹配close方法，再去匹配shutdown方法")]),e._v(" "),s("h4",{attrs:{id:"spring启动过程源码解析"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#spring启动过程源码解析"}},[e._v("#")]),e._v(" Spring启动过程源码解析")]),e._v(" "),s("h4",{attrs:{id:"aop源码类详解"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#aop源码类详解"}},[e._v("#")]),e._v(" AOP源码类详解")]),e._v(" "),s("p",[e._v("自动代理创建器")]),e._v(" "),s("p",[e._v("AbstractAutoProxyCreator")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[e._v("BeanNameAutoProxyCreator\nDefaultAdvisorAutoProxyCreator\nAnnotationAwareAspectJAutoProxyCreator\n")])])]),s("p",[e._v("BeanNameAutoProxyCreator:")]),e._v(" "),s("ol",[s("li",[e._v("因为实现了BeanPostProcessor,且实现了postProcessAfterInitialization方法，被spring管理的Bean，到最后都会执行此方法")]),e._v(" "),s("li",[e._v("根据外部手动调用setBeanNames()来确定那些Bean需要被进行aop代理")]),e._v(" "),s("li",[e._v("得到根据外部手动调用的setInterceptorNames()传入的代理逻辑")]),e._v(" "),s("li",[e._v("使用ProxyFactory来创建代理对象")])]),e._v(" "),s("p",[e._v("DefaultAdvisorAutoProxyCreator")]),e._v(" "),s("ol",[s("li",[e._v("因为实现了BeanPostProcessor,且实现了postProcessAfterInitialization方法，被spring管理的Bean，到最后都会执行此方法")]),e._v(" "),s("li",[e._v("拿到spring容器中所有的实现了Advisor的类")]),e._v(" "),s("li",[e._v("循环拿到的Advisor集合，判断当前初始化的Bean是否需要被代理（根据Advisor的具体实现类来判断ClassFilter，Method）")]),e._v(" "),s("li",[e._v("使用ProxyFactory来创建代理对象")])]),e._v(" "),s("p",[e._v("AnnotationAwareAspectJAutoProxyCreator")]),e._v(" "),s("ol",[s("li",[e._v("因为实现了BeanPostProcessor,且实现了postProcessAfterInitialization方法，被spring管理的Bean，到最后都会执行此方法")]),e._v(" "),s("li",[e._v("拿到spring容器中所有的实现了Advisor的类 + AspectJ的代理逻辑")]),e._v(" "),s("li",[e._v("循环拿到的Advisor集合，判断当前初始化的Bean是否需要被代理（根据Advisor的具体实现类来判断ClassFilter，Method）")]),e._v(" "),s("li",[e._v("使用ProxyFactory来创建代理对象")])]),e._v(" "),s("h4",{attrs:{id:"循环引用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#循环引用"}},[e._v("#")]),e._v(" 循环引用")]),e._v(" "),s("p",[s("img",{attrs:{src:"https://gitee.com/lxk_kaige/blogImage/raw/master/img/1.png",alt:"1592539097062-7912a20c-f209-47bd-bdc0-d6d4485ab395"}})]),e._v(" "),s("p",[s("strong",[e._v("singletonObjects")]),e._v("：（"),s("strong",[e._v("一级缓存")]),e._v("）缓存某个beanName对应的经过了完整生命周期的bean")]),e._v(" "),s("p",[s("strong",[e._v("earlySingletonObjects")]),e._v("：（"),s("strong",[e._v("二级缓存")]),e._v("）缓存提前通过原始对象进行了AOP之后得到的代理对象，原始对象还没有进行属性注入和后续的BeanPostProcessor等生命周期")]),e._v(" "),s("p",[s("strong",[e._v("singletonFactories")]),e._v("：（"),s("strong",[e._v("三级缓存")]),e._v("）缓存的是一个ObjectFactory，也就是一个Lambda表达式。在创建一个Bean时，在每个Bean的生成过程中，都会提前暴露一个Lambda表达式，并保存到三级缓存中，这个Lambda表达式"),s("strong",[e._v("可能用到，也可能用不到")]),e._v("，如果没有出现循环依赖依赖本bean，那么这个Lambda表达式无用，本bean按照自己的生命周期执行，执行完后直接把本bean放入singletonObjects中即可，如果出现了循环依赖依赖了本bean，则从三级缓存中获取Lambda表达式，并执行Lambda表达式得到一个AOP之后的代理对象(如果有AOP的话，如果无需AOP，则直接得到一个原始对象)，并把得到的对象放入二级缓存")]),e._v(" "),s("p",[e._v("其实还要一个缓存，就是"),s("strong",[e._v("earlyProxyReferences")]),e._v("，它用来记录某个原始对象是否进行过AOP了。")]),e._v(" "),s("h3",{attrs:{id:"_3-springmvc相关"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-springmvc相关"}},[e._v("#")]),e._v(" 3. springMvc相关")]),e._v(" "),s("h4",{attrs:{id:"_3-1-pringframework实现无xml配置mvc项目"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-pringframework实现无xml配置mvc项目"}},[e._v("#")]),e._v(" 3.1 pringFramework实现无XML配置mvc项目")]),e._v(" "),s("p",[e._v("springFramework  2.5   以后，官方文档已经推荐我们使用注解的方式去配置mvc项目，不用像以前一样配置繁琐的xml ( applicationContext.xml，applicationMvc.xml ....) 以及web.xml。")]),e._v(" "),s("p",[s("strong",[e._v("由于springmvc是基于servlet Api构建的，在servlet 3.0 以前，让servlet容器加载项目，只有一个入口，那就是web.xml，只有项目中有此web.xml，servlet容器（例如：tomcat） 才能以此为入口，进一步初始化项目。")])]),e._v(" "),s("p",[s("strong",[e._v("而在servlet 3.0 以后：")])]),e._v(" "),s("ol",[s("li",[e._v("只要项目指定目录META-IF/services目录下有以javax.servlet.ServletContainerInitializer命名的文件，并在文件中写入实现了ServletContainerInitializer接口的类的全路径名，那么servlet容器就可以检测到。而springFramework 2.5 后的版本中正是巧妙的运用了此方法，在spring-web项目中，就有此文件。")])]),e._v(" "),s("p",[s("img",{attrs:{src:"C:%5CUsers%5CLXK%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1582728498915.png",alt:"1582728498915"}})]),e._v(" "),s("ol",{attrs:{start:"2"}},[s("li",[e._v("前面说过，servlet 3.0 提供了另一个入口，在servlet容器检测到实现了ServletContainerInitializer接口的类后，就会执行此类的onStartup()方法进行项目初始化。spring用@HandlesTypes( ) 配合使用，在执行onStartup()方法时，检测实现了@HandlesTypes标记的类，并把此类作为参数放入onStartup()方法的第一个参数，而后循环进行onStartup()方法。")])]),e._v(" "),s("p",[s("img",{attrs:{src:"C:%5CUsers%5CLXK%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1582729173330.png",alt:"1582729173330"}})]),e._v(" "),s("p",[s("img",{attrs:{src:"C:%5CUsers%5CLXK%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1582729206152.png",alt:"1582729206152"}})]),e._v(" "),s("p",[e._v("那么spring  2.5  以后的版本中，spring具体是如何实现零xml配置，基于注解就可以方便得配置项目呢?")]),e._v(" "),s("p",[e._v("在spring  2.5  以前，各个配置文件都配置了那些内容呢？")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("<web-app>\n\t// 配置ContextLoaderListener监听器,加载spring配置文件并初始化spring环境\n    <listener>\n        <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>\n    </listener>\n\n    <context-param>\n        <param-name>contextConfigLocation</param-name>\n        <param-value>/WEB-INF/app-context.xml</param-value>\n    </context-param>\n\t//配置DispatcherServlet，并加载springmvc配置文件\n    <servlet>\n        <servlet-name>app</servlet-name>\n        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n        <init-param>\n            <param-name>contextConfigLocation</param-name>\n            <param-value>classpath:springmvc-config.xml</param-value>\n        </init-param>\n        <load-on-startup>1</load-on-startup>\n    </servlet>\n\n    <servlet-mapping>\n        <servlet-name>app</servlet-name>\n        <url-pattern>/app/*</url-pattern>\n    </servlet-mapping>\n\n</web-app>\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br"),s("span",{staticClass:"line-number"},[e._v("15")]),s("br"),s("span",{staticClass:"line-number"},[e._v("16")]),s("br"),s("span",{staticClass:"line-number"},[e._v("17")]),s("br"),s("span",{staticClass:"line-number"},[e._v("18")]),s("br"),s("span",{staticClass:"line-number"},[e._v("19")]),s("br"),s("span",{staticClass:"line-number"},[e._v("20")]),s("br"),s("span",{staticClass:"line-number"},[e._v("21")]),s("br"),s("span",{staticClass:"line-number"},[e._v("22")]),s("br"),s("span",{staticClass:"line-number"},[e._v("23")]),s("br"),s("span",{staticClass:"line-number"},[e._v("24")]),s("br"),s("span",{staticClass:"line-number"},[e._v("25")]),s("br"),s("span",{staticClass:"line-number"},[e._v("26")]),s("br"),s("span",{staticClass:"line-number"},[e._v("27")]),s("br")])]),s("p",[e._v("由上面代码可以看到，在一个简单的mvc项目中，web.xml主要是用来配置ContextLoaderListener监听器用来初始化spring环境，注册DispatcherServlet这个servlet。也就是当作一个servlet容器的入口处，用来初始化项目。")]),e._v(" "),s("p",[s("strong",[e._v("代替web.xml")])]),e._v(" "),s("img",{staticStyle:{zoom:"200%"},attrs:{src:"C:\\Users\\LXK\\AppData\\Roaming\\Typora\\typora-user-images\\1582729403390.png",alt:"1582729403390"}}),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("WebEnvironmentInitializer实现了WebApplicationInitializer接口，spring中实现了ServletContainerInitializer接口的类为SpringServletContainerInitializer，此类上的注解@HandlesTypes标记的正是WebApplicationInitializer.class。\n\n所以在tomcat容器执行SpringServletContainerInitializer的onStartup()方法时，会检测@HandlesTypes标记的WebApplicationInitializer接口的实现了，并放入onStartup()中循环执行它的onStartup()。\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br")])]),s("p",[s("strong",[e._v("代替application-context.xml , application-mvc.xml")])]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("application-context.xml \n\n此类xml中最主要的就是扫描Bean,此项工作可以交给@ComponentScan()完成，@ComponentScan()会扫描指定的包中的类，并根据条件注册进spring容器中。\n其他皆是配置Bean的配置，可以用@Bean完成。\n\napplication-mvc.xml\n可以使用@Bean的方式配置mvc的一些东西，例如：消息转换器，视图解析器。。。\n也可以在配置类中加上@EnableWebMvc并实现WebMvcConfigurer接口来配置。\n\n如果实现了WebMvcConfigurer接口，则必须加@EnableWebMvc注解，此时0xml配置类的onStartup方法中初始化spring上下文的Context就不能调用refresh方法了\n\n如果继承了WebMvcConfigurationSupport类，则可以不加@EnableWebMvc注解，此时0xml配置类的onStartup方法中初始化spring上下文的Context就不能调用refresh方法了\n\n\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br")])]),s("h4",{attrs:{id:"_3-2-内嵌tomcat"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-内嵌tomcat"}},[e._v("#")]),e._v(" 3.2 内嵌tomcat")]),e._v(" "),s("p",[e._v("基于上面的无XML配置的mvc项目，可以使用内嵌tomcat来启动项目")]),e._v(" "),s("p",[s("img",{attrs:{src:"C:%5CUsers%5CLXK%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1593682786926.png",alt:"1593682786926"}})]),e._v(" "),s("p",[e._v("springMvc对于静态资源的匹配，采用的客户端缓存，当一个客户端第二次请求同一个静态资源时，判断此资源是否更改过，如果没有，则直接返回客户端HTTP状态码 304 ，客户端收到此状态码会去浏览器缓存中去找此静态资源")]),e._v(" "),s("h3",{attrs:{id:"_3-3-springmvc源码解析"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-springmvc源码解析"}},[e._v("#")]),e._v(" 3.3 springMvc源码解析")]),e._v(" "),s("ul",[s("li",[s("h4",{attrs:{id:"springmvc初始化controller的流程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#springmvc初始化controller的流程"}},[e._v("#")]),e._v(" springMvc初始化Controller的流程")])]),e._v(" "),s("li",[s("p",[e._v("DispatcherServlet的类图")])])]),e._v(" "),s("p",[s("img",{attrs:{src:"C:%5CUsers%5CLXK%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1594026941590.png",alt:"1594026941590"}})]),e._v(" "),s("ol",[s("li",[s("p",[e._v("org.springframework.web.servlet.HttpServletBean#init")])]),e._v(" "),s("li",[s("p",[e._v("org.springframework.web.servlet.FrameworkServlet#initServletBean")])]),e._v(" "),s("li",[s("p",[e._v("org.springframework.web.servlet.FrameworkServlet#initWebApplicationContext")])]),e._v(" "),s("li",[s("p",[e._v("org.springframework.web.servlet.FrameworkServlet#configureAndRefreshWebApplicationContext")])]),e._v(" "),s("li",[s("p",[e._v("org.springframework.context.support.AbstractApplicationContext#refresh(初始化spring环境)")])]),e._v(" "),s("li",[s("p",[e._v("org.springframework.context.support.AbstractApplicationContext#finishRefresh(代码走到这里spring环境已经初始化完毕，开始最后发布事件，由对应的监听处理事件也就是开始执行springmvc的相关初始化)")])]),e._v(" "),s("li",[s("p",[e._v("org.springframework.context.support.AbstractApplicationContext#publishEvent(org.springframework.context.ApplicationEvent)")])]),e._v(" "),s("li",[s("p",[e._v("。。。。")])]),e._v(" "),s("li",[s("p",[e._v("org.springframework.web.servlet.FrameworkServlet.ContextRefreshListener#onApplicationEvent")])]),e._v(" "),s("li",[s("p",[e._v("org.springframework.web.servlet.FrameworkServlet#onApplicationEvent")])]),e._v(" "),s("li",[s("p",[e._v("org.springframework.web.servlet.DispatcherServlet#initStrategies")])]),e._v(" "),s("li",[s("p",[e._v("org.springframework.web.servlet.DispatcherServlet#initHandlerMappings")])]),e._v(" "),s("li",[s("p",[e._v("org.springframework.web.servlet.handler.AbstractHandlerMethodMapping#afterPropertiesSet")])]),e._v(" "),s("li",[s("p",[e._v("org.springframework.web.servlet.handler.AbstractHandlerMethodMapping#initHandlerMethods")])])]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("springmvc的初始化在spring环境初始化完成后，通过发布事件的方式由指定的监听来执行\nFrameworkServlet.this.onApplicationEvent(event);\n\nDispatcherServlet实际上就是一个servlet,servlet有三个应用最普遍的方init(),doGet(),doPost()。\n而SpringMvc就是在DispatcherServlet实例化完成后，由servlet容器调用init()方法进行环境的初始化的，其中就包括对controller的解析\n\n环境初始化走到org.springframework.web.servlet.DispatcherServlet#initHandlerMappings方法时，会去解析spring-webmvc项目的DispatcherServlet.properties文件，去实例化默认的两个HandlerMapping（BeanNameUrlHandlerMapping,RequestMappingHandlerMapping）因为RequestMappingHandlerMapping的父类实现了InitializingBean接口，当他走完Bean的生命周期后，会调用afterPropertiesSet()方法,继而调用initHandlerMethods()方法去加载controller并放入MappingRegistry.urlLookup和MappingRegistry.mappingLookup\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br")])]),s("ul",[s("li",[s("h4",{attrs:{id:"springmvc根据请求找controller的流程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#springmvc根据请求找controller的流程"}},[e._v("#")]),e._v(" SpringMvc根据请求找Controller的流程")]),e._v(" "),s("ol",[s("li",[e._v("org.springframework.web.servlet.FrameworkServlet#doGet org.springframework.web.servlet.FrameworkServlet#doPost")]),e._v(" "),s("li",[e._v("org.springframework.web.servlet.FrameworkServlet#processRequest")]),e._v(" "),s("li",[e._v("org.springframework.web.servlet.DispatcherServlet#doService")]),e._v(" "),s("li",[e._v("org.springframework.web.servlet.DispatcherServlet#doDispatch")]),e._v(" "),s("li",[e._v("org.springframework.web.servlet.DispatcherServlet#getHandler")]),e._v(" "),s("li",[e._v("org.springframework.web.servlet.handler.AbstractHandlerMethodMapping#getHandlerInternal或org.springframework.web.servlet.handler.AbstractUrlHandlerMapping#getHandlerInternal")]),e._v(" "),s("li",[e._v("org.springframework.web.servlet.handler.AbstractHandlerMethodMapping#lookupHandlerMethod")]),e._v(" "),s("li",[e._v("org.springframework.web.servlet.handler.AbstractHandlerMethodMapping.MappingRegistry#urlLookup或org.springframework.web.servlet.handler.AbstractHandlerMethodMapping.MappingRegistry#mappingLookup")])]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("核心代码在DispatcherServlet的doDispatch()方法，此方法作用：\n1. 首先确定处理请求的controller的方法(附带拦截此方法的拦截器)\n2. 得到对应的handlerAdapter\n3. 方法执行前，执行拦截器\n4. 对应请求的方法参数赋值\n5. 调用目标方法\n6. 调用视图解析器或消息转换器\n7. 方法执行后，执行拦截器\n8. 方法返回后，执行拦截器\n\n此处只分析如何匹配请求对应的方法\n在org.springframework.web.servlet.DispatcherServlet#getHandler方法中，根据提供的handlerMappings循环遍历去匹配路径。\n\nhandlerMappings默认情况下，有两个(通过解析DispatcherServlet.properties文件)类，RequestMappingHandlerMapping与BeanNameUrlHandlerMapping对应上面的第六步，而获取对应的handlerAdapter也是根据这个来的，对应doDispatch()的第二步\n\nRequestMappingHandlerMapping用来处理通过@Controller的方式成为controller的类\nBeanNameUrlHandlerMapping用来处理通过实现Controller或HttpRequestHandler接口的方式程为controller的类\n\n最后走到lookupHandlerMethod()方法，根据request中的uri和urlLookup或mappingLookup去匹配\n\n\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br"),s("span",{staticClass:"line-number"},[e._v("15")]),s("br"),s("span",{staticClass:"line-number"},[e._v("16")]),s("br"),s("span",{staticClass:"line-number"},[e._v("17")]),s("br"),s("span",{staticClass:"line-number"},[e._v("18")]),s("br"),s("span",{staticClass:"line-number"},[e._v("19")]),s("br"),s("span",{staticClass:"line-number"},[e._v("20")]),s("br"),s("span",{staticClass:"line-number"},[e._v("21")]),s("br")])])]),e._v(" "),s("li",[s("h4",{attrs:{id:"springmvc方法参数赋值"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#springmvc方法参数赋值"}},[e._v("#")]),e._v(" SpringMvc方法参数赋值")]),e._v(" "),s("ol",[s("li",[s("p",[e._v("org.springframework.web.servlet.DispatcherServlet#doDispatch")])]),e._v(" "),s("li",[s("p",[e._v("org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter#handle")])]),e._v(" "),s("li",[s("p",[e._v("org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter#handleInternal")])]),e._v(" "),s("li",[s("p",[e._v("org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter#invokeHandlerMethod")])]),e._v(" "),s("li",[s("p",[e._v("org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod#invokeAndHandle")])]),e._v(" "),s("li",[s("p",[e._v("org.springframework.web.method.support.InvocableHandlerMethod#invokeForRequest")])]),e._v(" "),s("li",[s("p",[e._v("org.springframework.web.method.support.InvocableHandlerMethod#getMethodArgumentValues")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("默认提供三种HandlerAdapter来进行方法参数赋值以及调用\norg.springframework.web.servlet.mvc.HttpRequestHandlerAdapter,\\\norg.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter,\\\norg.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter\n分别对应三种不同方式成为controller的类\n\n此处只分析RequestMappingHandlerAdapter(最常用)\n方法参数赋值的逻辑就在org.springframework.web.method.support.InvocableHandlerMethod#getMethodArgumentValues中\n首先根据参数的属性找到符合条件的HandlerMethodArgumentResolver，然后将参数替换，此处有一个缓存，用来缓存已经解析过的方法参数以及参数对应的HandlerMethodArgumentResolver,因为寻找HandlerMethodArgumentResolver的操作还是挺费时间的，正常状态下有多达26个HandlerMethodArgumentResolver\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br")])])])])]),e._v(" "),s("li",[s("h4",{attrs:{id:"springmvc如何返回数据的"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#springmvc如何返回数据的"}},[e._v("#")]),e._v(" SpringMvc如何返回数据的")])])]),e._v(" "),s("ol",[s("li",[s("p",[e._v("org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter#handle")])]),e._v(" "),s("li",[s("p",[e._v("org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter#handleInternal")])]),e._v(" "),s("li",[s("p",[e._v("org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter#invokeHandlerMethod")])]),e._v(" "),s("li",[s("p",[e._v("org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod#invokeAndHandle")])]),e._v(" "),s("li",[s("p",[e._v("org.springframework.web.method.support.HandlerMethodReturnValueHandlerComposite#handleReturnValue")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("返回数据在执行方法之后\n在第5步，handleReturnValue中\n//寻找合适的返回参数解析器 例如：方法上加了@ResponseBody 就会用RequestResponseBodyMethodProcessor\nHandlerMethodReturnValueHandler handler = selectHandler(returnValue, returnType);\n\n// 例如：方法上加了@ResponseBody就会把返回参数格式化为json并响应\nhandler.handleReturnValue(returnValue, returnType, mavContainer, webRequest);\n\n如果方法返回是一个视图，那么会返回到最外层的DisPatcherServlet处理，首先会匹配合适的视图解析器，然后经过一系列的流程(是转发还是重定向。。)最终转发或重定向视图\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br")])])])]),e._v(" "),s("ul",[s("li",[s("h4",{attrs:{id:"springboot如何扩展springmvc-实现响应静态资源"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#springboot如何扩展springmvc-实现响应静态资源"}},[e._v("#")]),e._v(" SpringBoot如何扩展SpringMvc，实现响应静态资源")])])]),e._v(" "),s("p",[e._v("SimpleUrlHandlerMapping")]),e._v(" "),s("h3",{attrs:{id:"_3-4-springmvc扩展点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-4-springmvc扩展点"}},[e._v("#")]),e._v(" 3.4 springMvc扩展点")]),e._v(" "),s("ul",[s("li",[s("h4",{attrs:{id:"handlermapping"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#handlermapping"}},[e._v("#")]),e._v(" HandlerMapping")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("HandlerMapping用来匹配请求对应的处理方法，springboot就是扩展了HandlerMapping实现web程序下可以响应resources目录下的静态资源文件(springmvc只能相应webapp下的静态资源)\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br")])])]),e._v(" "),s("li",[s("h4",{attrs:{id:"handlermethodargumentresolver"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#handlermethodargumentresolver"}},[e._v("#")]),e._v(" HandlerMethodArgumentResolver")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("请求对应的处理方法的参数赋值，可以自定义。\n例如：项目中某些方法需要获取用户信息，在方法参数中直接赋值的方式，就可以使用实现HandlerMethodArgumentResolver来实现。\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br")])])]),e._v(" "),s("li",[s("h4",{attrs:{id:"handlermethodreturnvaluehandler"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#handlermethodreturnvaluehandler"}},[e._v("#")]),e._v(" HandlerMethodReturnValueHandler")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("请求对应的处理方法执行完毕，返回时的解析器,可以当作扩展点使用\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br")])])]),e._v(" "),s("li",[s("h4",{attrs:{id:"viewresolver"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#viewresolver"}},[e._v("#")]),e._v(" ViewResolver")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("视图解析器\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br")])]),s("h4",{attrs:{id:"converter"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#converter"}},[e._v("#")]),e._v(" Converter")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("类型转换器，例如映射方法形参为Date类型，前端发过来是json字符串，将字符串转换为Date的参数解析\nString---\x3eDate，mvc有默认的Converter转换器，但是形参出必须加@DateTimeFormat注解，并且指定patten的格式化，而且格式必须与入参格式一致\n\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br")])])])]),e._v(" "),s("h3",{attrs:{id:"_10-spring与mvc杂项"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_10-spring与mvc杂项"}},[e._v("#")]),e._v(" 10. spring与mvc杂项")]),e._v(" "),s("h4",{attrs:{id:"_10-1父子容器问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_10-1父子容器问题"}},[e._v("#")]),e._v(" 10.1父子容器问题")]),e._v(" "),s("p",[e._v("​\t有spring的容器为父容器，springmvc为子容器。")]),e._v(" "),s("p",[e._v("​\t子容器可以获取父容器的bean对象，父容器不可获取子容器的bean对象")]),e._v(" "),s("p",[e._v('​\t注意：这里仅是bean，对于一些属性文件@Value("${server.name}") 子容器也是获取不到的')]),e._v(" "),s("h3",{attrs:{id:"_3-springboot"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-springboot"}},[e._v("#")]),e._v(" 3. springBoot")]),e._v(" "),s("h4",{attrs:{id:"_1-1-springboot-自动配置原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-springboot-自动配置原理"}},[e._v("#")]),e._v(" 1.1 springBoot 自动配置原理")]),e._v(" "),s("p",[e._v("springBoot默认会去解析项目"),s("strong",[e._v("resources/META-INF/spring.factories")]),e._v("配置文件，并会加载配置文件中的类注入到spring容器中去。")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("springboot的启动类中添加的@SpringBootApplication注解完成了这一功能，他是一个组合注解，真正完成这一功能的是@EnableAutoConfiguration注解，此注解使用@Import导入了一个AutoConfigurationImportSelector类，此类实现了ImportSelector接口，在spring初始化环境，扫描到有@Import注解后，将@Import中的类注册成为一个BeanDefinition并且，如果此类实现了ImportSelector接口，那么直接执行ImportSelector接口的selectImports方法，AutoConfigurationImportSelector类的selectImports方法会去解析spring.factories配置文件，并将配置文件中的类，注册到spring环境中。\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br")])]),s("p",[e._v("自动配置mvc：WebMvcAutoConfiguration")]),e._v(" "),s("p",[e._v("自动配置DisPatcherServlet：DispatcherServletAutoConfiguration")]),e._v(" "),s("h4",{attrs:{id:"_1-2-springboot-监听器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-springboot-监听器"}},[e._v("#")]),e._v(" 1.2 springBoot 监听器")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("举例说明：\n事件：小明和小红打了一架\n事件源：\n事件对象：打架的过程\n事件驱动器：管理事件\n\n事件驱动器\nSimpleApplicationEventMulticaster\n\n在spring容器启动调用refresh()时，\ninitApplicationEventMulticaster()方法会去初始化事件驱动器。\nregisterListeners()方法会去初始化实现了ApplicationListener接口的监听类\nfinishBeanFactoryInitialization(beanFactory);方法不仅会调用spring的后置处理器，当所有的bean初始化完成后，还会初始化所有的以注解形式实现的监听类\n\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br")])]),s("h4",{attrs:{id:"_1-3-内置web容器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-内置web容器"}},[e._v("#")]),e._v(" 1.3 内置web容器")]),e._v(" "),s("p",[s("strong",[e._v("配置web容器")]),e._v("：")]),e._v(" "),s("ol",[s("li",[e._v("yml配置")]),e._v(" "),s("li",[e._v("TomcatServletWebServerFactory")])]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("/**\n     * 配置web容器第一种方式\n     * @return\n     */\n    @Bean\n    public TomcatServletWebServerFactory tomcatServletWebServerFactory() {\n        TomcatServletWebServerFactory tomcatServletWebServerFactory = new TomcatServletWebServerFactory();\n        tomcatServletWebServerFactory.setPort(8081);\n        return tomcatServletWebServerFactory;\n    }\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br")])]),s("ol",{attrs:{start:"3"}},[s("li",[e._v("WebServerFactoryCustomizer")])]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v(" /**\n     * 配置web容器第二种方式\n     * 优先级：WebServerFactoryCustomizer > yml > TomcatServletWebServerFactory\n     * @return\n     */\n    @Bean\n    public WebServerFactoryCustomizer webServerFactoryCustomizer() {\n        //factory 为当前正在使用的web容器的Factory\n        WebServerFactoryCustomizer webServerFactoryCustomizer = factory -> {\n            TomcatServletWebServerFactory factory1 = (TomcatServletWebServerFactory) factory;\n            factory1.setPort(8088);\n        };\n        return webServerFactoryCustomizer;\n    }\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br")])]),s("p",[e._v("对于以上配置，只能配置springBoot已经确定使用哪个web容器了，配置此web容器的一些配置，并不能够切换web容器。")]),e._v(" "),s("p",[s("strong",[e._v("切换web容器")])]),e._v(" "),s("p",[e._v("springBoot自动配置web容器的类是ServletWebServerFactoryAutoConfiguration类（在"),s("strong",[e._v("spring-boot-autoconfigure包下的resources/META-INF/spring.factories")]),e._v("）")]),e._v(" "),s("p",[e._v("默认情况下springboot配置的web容器为tomcat，在源码中可以看到")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("ServletWebServerFactoryAutoConfiguration类的@Import({ServletWebServerFactoryAutoConfiguration.BeanPostProcessorsRegistrar.class, EmbeddedTomcat.class, EmbeddedJetty.class, EmbeddedUndertow.class})\n导入的类中，包含三种web容器分别为:Tomcat,Jetty,Undertow。\n在这三个EmbeddedTomcat，EmbeddedJetty，EmbeddedUndertow类中，都有\n@ConditionalOnMissingBean(\n        value = {ServletWebServerFactory.class},\n        search = SearchStrategy.CURRENT\n    )\n    注解，表示如果spring容器中存在某个接口或实现类，那么就不会将加了此注解的类放入spring容器中，又因为EmbeddedTomcat排在第一个，当解析完EmbeddedTomcat类后，spring容器中存在了一个TomcatServletWebServerFactory，此类实现了ServletWebServerFactory接口，所以后面的两个web容器就不会注入到spring环境中了。\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br")])]),s("p",[e._v("如果想要切换默认的web容器，需要在springboot的包中，剔除tomcat的包，在引入其他web容器的包即可。")]),e._v(" "),s("p",[e._v("注意：")]),e._v(" "),s("ol",[s("li",[s("p",[e._v("springboot项目如果使用jar包的方式，那么springboot会屏蔽掉servlet 3.0的规范，也就是说实现WebApplicationInitializer接口，servlet容器并不会调用onStartup()方法，但是如果使用war包的情况下，默认是没有屏蔽的。")]),e._v(" "),s("p",[e._v("jar包方式，如果想要实现相同的功能，springboot提供了另外一个接口ServletContextInitializer")])]),e._v(" "),s("li",[s("p",[e._v("如果项目中有类继承了WebMvcConfigurationSupport类，会导致springBoot自动配置mvc失效，因为WebMvcAutoConfiguration自动配置类中有一个注解@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)")])])]),e._v(" "),s("h4",{attrs:{id:"_1-4-启动源码分析"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-4-启动源码分析"}},[e._v("#")]),e._v(" 1.4 启动源码分析")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("构造方法：\nApplicationContextInitializer\nApplicationListener\nrun方法：\nSpringApplicationRunListener\nApplicationRunner，CommandLineRunner\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br")])]),s("p",[s("img",{attrs:{src:"https://gitee.com/lxk_kaige/blogImage/raw/master/img/image-20200831143553749.png",alt:"image-20200831143553749"}})]),e._v(" "),s("h4",{attrs:{id:"_1-5-默认拦截静态资源"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-5-默认拦截静态资源"}},[e._v("#")]),e._v(" 1.5 默认拦截静态资源")]),e._v(" "),s("p",[e._v("springMvc中接收外部请求的唯一入口最终都会执行DisPatcherServlet的doDispatch方法")]),e._v(" "),s("p",[e._v("在doDispatch方法中org.springframework.web.servlet.DispatcherServlet#getHandler是一个重点，他来确定具体要哪个方法处理外部的请求以及拦截此请求的拦截器")]),e._v(" "),s("p",[s("img",{attrs:{src:"https://gitee.com/lxk_kaige/blogImage/raw/master/img/image-20200914173843128.png",alt:"image-20200914173630960"}})]),e._v(" "),s("p",[s("img",{attrs:{src:"https://gitee.com/lxk_kaige/blogImage/raw/master/img/image-20200914173843128.png",alt:"image-20200914174256705"}})]),e._v(" "),s("p",[s("img",{attrs:{src:"https://gitee.com/lxk_kaige/blogImage/raw/master/img/image-20200914173843128.png",alt:"image-20200914173843128"}})]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("AbstractHandlerMethodMapping 处理外部请求对应的处理方法(controller下的方法)\nAbstractUrlHandlerMapping 处理静态资源\n\nHandlerExecutionChain\nResourceHttpRequestHandler\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br")])]),s("p",[e._v("最后执行到org.springframework.web.servlet.HandlerAdapter#handle方法，是最终执行请求对应方法/寻找请求对应资源的方法，寻找请求对应的资源org.springframework.web.servlet.resource.ResourceHttpRequestHandler#handleRequest的getResource()方法中")]),e._v(" "),s("p",[s("img",{attrs:{src:"https://gitee.com/lxk_kaige/blogImage/raw/master/img/image-20200915090146901.png",alt:"image-20200915090146901"}})]),e._v(" "),s("p",[e._v("根据org.springframework.boot.autoconfigure.web.ResourceProperties#CLASSPATH_RESOURCE_LOCATIONS中默认的几种去找对应的资源，找到后返回")]),e._v(" "),s("ol",[s("li",[e._v("classpath:/META-INF/resources/")]),e._v(" "),s("li",[e._v("classpath:/resources/")]),e._v(" "),s("li",[e._v("classpath:/static/")]),e._v(" "),s("li",[e._v("classpath:/public/")]),e._v(" "),s("li",[e._v("webapp下的resources、static、public")])]),e._v(" "),s("p",[e._v("由此可见，如果我们要扩展静态资源的映射可以从ResourceProperties的staticLocations[]入手")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('@SpringBootApplication\npublic class AppApplication implements WebMvcConfigurer, InitializingBean {\n\t@Autowired\n\tResourceProperties resourceProperties;\n\n\t/**\n\t * 第二种方式：通过实现WebMvcConfigurer接口，重写其中的addResourceHandlers方法\n\t * 可以指定指定的请求去找指定的资源路径\n\t *\n\t * @param registry\n\t */\n\t@Override\n\tpublic void addResourceHandlers(ResourceHandlerRegistry registry) {\n\t\tregistry.addResourceHandler("/aa/**")\n\t\t\t\t.addResourceLocations("classpath:/aa/");\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(AppApplication.class);\n\t}\n\n\t/**\n\t * 第一种方式：直接扩展staticLocations数组，在数组中添加新的路径，但是这种只支持/**所有外部请求，不能指定想要拦截的路径\n\t *\n\t * @throws Exception\n\t */\n\t@Override\n\tpublic void afterPropertiesSet() throws Exception {\n\t\tString[] staticLocations = resourceProperties.getStaticLocations();\n\t\tList<String> list = new ArrayList<>();\n\t\tlist.addAll(Arrays.asList(staticLocations));\n\t\tlist.add("classpath:/aa/");\n\t\tString[] str = new String[list.size()];\n\t\tresourceProperties.setStaticLocations(list.toArray(str));\n\t}\n}\n')])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br"),s("span",{staticClass:"line-number"},[e._v("15")]),s("br"),s("span",{staticClass:"line-number"},[e._v("16")]),s("br"),s("span",{staticClass:"line-number"},[e._v("17")]),s("br"),s("span",{staticClass:"line-number"},[e._v("18")]),s("br"),s("span",{staticClass:"line-number"},[e._v("19")]),s("br"),s("span",{staticClass:"line-number"},[e._v("20")]),s("br"),s("span",{staticClass:"line-number"},[e._v("21")]),s("br"),s("span",{staticClass:"line-number"},[e._v("22")]),s("br"),s("span",{staticClass:"line-number"},[e._v("23")]),s("br"),s("span",{staticClass:"line-number"},[e._v("24")]),s("br"),s("span",{staticClass:"line-number"},[e._v("25")]),s("br"),s("span",{staticClass:"line-number"},[e._v("26")]),s("br"),s("span",{staticClass:"line-number"},[e._v("27")]),s("br"),s("span",{staticClass:"line-number"},[e._v("28")]),s("br"),s("span",{staticClass:"line-number"},[e._v("29")]),s("br"),s("span",{staticClass:"line-number"},[e._v("30")]),s("br"),s("span",{staticClass:"line-number"},[e._v("31")]),s("br"),s("span",{staticClass:"line-number"},[e._v("32")]),s("br"),s("span",{staticClass:"line-number"},[e._v("33")]),s("br"),s("span",{staticClass:"line-number"},[e._v("34")]),s("br"),s("span",{staticClass:"line-number"},[e._v("35")]),s("br"),s("span",{staticClass:"line-number"},[e._v("36")]),s("br")])]),s("h6",{attrs:{id:"遇到的问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#遇到的问题"}},[e._v("#")]),e._v(" "),s("strong",[e._v("遇到的问题")])]),e._v(" "),s("p",[s("strong",[e._v("为什么存放在webapp/resources/此文件夹下的静态文件，访问时可以直接通过classpath:/resources/找到相应静态文件？")])]),e._v(" "),s("p",[e._v("idea在编译后，会将webapp/resources/转换为classpath（target\\classes）下面的resources文件夹里面")]),e._v(" "),s("h3",{attrs:{id:"_4-spring-源码编译"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-spring-源码编译"}},[e._v("#")]),e._v(" 4. spring 源码编译")]),e._v(" "),s("h5",{attrs:{id:"问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#问题"}},[e._v("#")]),e._v(" 问题：")]),e._v(" "),s("p",[e._v("找不到org.springframework.aop.target")]),e._v(" "),s("p",[e._v("因为我在Idea的设置中，将名称为target的目录给隐藏了")]),e._v(" "),s("p",[e._v('requestMappingHandlerMapping -> {ConfigurationClassBeanDefinitionReader$ConfigurationClassBeanDefinition@3381} "Root bean: class [null]; scope=; abstract=false; lazyInit=false; autowireMode=3; dependencyCheck=0; autowireCandidate=true; primary=false; factoryBeanName=org.springframework.web.servlet.config.annotation.DelegatingWebMvcConfiguration; factoryMethodName=requestMappingHandlerMapping; initMethodName=null; destroyMethodName=(inferred); defined in org.springframework.web.servlet.config.annotation.DelegatingWebMvcConfiguration"')]),e._v(" "),s("p",[e._v("docker start oracle11g")])])}),[],!1,null,null,null);a.default=n.exports}}]);